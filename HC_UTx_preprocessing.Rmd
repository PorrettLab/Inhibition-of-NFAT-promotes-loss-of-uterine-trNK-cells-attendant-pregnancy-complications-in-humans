---
title: "Inhibition of NFAT promotes loss of tissue resident uterine 1 natural killer cells and attendant pregnancy complications in humans"
subtitle: "Integrated Analysis of HC and UTx Datasets - QC"
author: "RA"
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: false
    lightbox: true
    downcute_theme: "chaos"
editor_options: 
  chunk_output_type: console
---

This vignette encapsulates analytics and QC steps conducted to preprocess Healthy Control and Uterine Transplant datasets (n=11) used in the generation of the manuscript: Inhibition of NFAT promotes loss of tissue resident uterine 1 natural killer cells and attendant pregnancy complications in humans 

### Load Required Packages
```{r}
suppressPackageStartupMessages({
  library(Seurat)
  library(ggplot2)
  library(patchwork)
  library(dplyr)
  library(hdf5r)
  library(ape)
  library(Rfast2)
  library(RColorBrewer)
  library(viridis)
  library(data.table)
  library(tidyverse)
  library(magrittr)
  library(gridExtra)
  library(cowplot)
  library(Matrix)
  library(reticulate)
  library(WebGestaltR)
  library(harmony)
  library(purrr)
  library(usefun)
  library(formattable)
  library(splitstackshape)
  library(formatR)
  library(venn)
  library(VennDiagram)
  library(Hmisc)
  library(interp)
  library(SoupX)
  library(knitr)
  library(pheatmap)
})
```

## Loading SoupX-filtered datasets

```{r}
file_paths <- list.files(path = here::here("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/SeuratObjects_Raw/"), pattern = ".rds", full.names = TRUE)

file_names <- gsub(pattern = "_SeuratObj.rds", replacement = "", x = basename(file_paths))

for(i in 1:length(file_names)){
  assign(file_names[i],readRDS(file_paths[i]))
}

#Checking data integrity on import
x <- readRDS("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/SeuratObjects_Raw/HBx20_SeuratObj.rds")
all.equal(x, HBx20)

x <- readRDS("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/SeuratObjects_Raw/HBx19_SeuratObj.rds")
all.equal(x, HBx19)

rm(x)
```

## Checking/Validating Details of each Object
```{r}
HBx01
head(HBx01@meta.data)
HBx01@assays

HBx10
head(HBx10@meta.data)
HBx10@assays

HBx12
head(HBx12@meta.data)
HBx12@assays

HBx18_CD45
head(HBx18_CD45@meta.data)
HBx18_CD45@assays

HBx19
head(HBx19@meta.data)
HBx19@assays

HBx20
head(HBx20@meta.data)
HBx20@assays

UTx01_Bx03
head(UTx01_Bx03@meta.data)
UTx01_Bx03@assays

UTx01_Bx04
head(UTx01_Bx04@meta.data)
UTx01_Bx04@assays

UTx01_Bx05
head(UTx01_Bx05@meta.data)
UTx01_Bx05@assays

UTx03_Bx02
head(UTx03_Bx02@meta.data)
UTx03_Bx02@assays

UTx03_Bx03
head(UTx03_Bx03@meta.data)
UTx03_Bx03@assays
```


Given some samples have two assays (CITE-Seq), we need to specify which assay we are working with at a time like so, for this run,  we'll set the assay to RNA:
```{r}
DefaultAssay(HBx01) <- 'RNA' 
DefaultAssay(HBx10) <- 'RNA' 
DefaultAssay(HBx12) <- 'RNA' 
DefaultAssay(HBx18_CD45) <- 'RNA' 
DefaultAssay(HBx19) <- 'RNA' 
DefaultAssay(HBx20) <- 'RNA' 
DefaultAssay(UTx01_Bx03) <- 'RNA' 
DefaultAssay(UTx01_Bx04) <- 'RNA' 
DefaultAssay(UTx01_Bx05) <- 'RNA' 
DefaultAssay(UTx03_Bx02) <- 'RNA' 
DefaultAssay(UTx03_Bx03) <- 'RNA' 
```


## Conducting QC on Each Sample

The steps below encompass pre-processing workflow for scRNA-seq data in Seurat. These represent the selection and filtration of cells based on QC metrics, data normalization and scaling, and the detection of highly variable features.

## Quality Control (QC)

Seurat allows us to easily explore QC metrics and filter cells based on any user-defined criteria. A few QC metrics [commonly used](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4758103/) by the community include:

* The number of unique genes detected in each cell. 
+ Low-quality cells or empty droplets will often have very few genes
+ Cell doublets or multiplets may exhibit an aberrantly high gene count
* Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes)
* The percentage of reads that map to the mitochondrial genome
+ Low-quality or dying cells often exhibit extensive mitochondrial contamination
+ We calculate mitochondrial QC metrics with the `PercentageFeatureSet()` function, which calculates the percentage of counts originating from a set of features
+ We use the set of all genes starting with `MT-` as a set of mitochondrial genes


## HBx01 QC

```{r,fig.height=7, fig.width=13}
#We'll store the percentage of reads that map to the mitochondrial genome in the metadata object as "percent.mt"
HBx01[["percent.mt"]] <- PercentageFeatureSet(HBx01, pattern = "^MT-")

#The number of unique genes and total molecules are automatically calculated during `CreateSeuratObject()` and we can find these stored in the object meta data as nFeature_RNA and nCount_RNA respecitvely.
HBx01@meta.data %>%
  head(n=5)
```

**Visualize QC metrics, and use these to filter cells**

```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx01, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx01, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx01, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)
```


```{r, message=FALSE, fig.width=20, fig.height=7}
#FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(HBx01, feature1 = "nCount_RNA", feature2 = "percent.mt", cols = "gray60")
plot2 <- FeatureScatter(HBx01, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", cols = "gray60")
plot1 + plot2
```

**Alternative view of the data and distributions**
```{r, fig.height=3}
df <- as.data.table(HBx01@meta.data)
sel <- c("orig.ident", "nCount_RNA", "nFeature_RNA", "percent.mt")
df <- df[, sel, with = FALSE]
df[1:3, ]
fontsize <- 10
linesize <- 0.35

gp.ls <- df[, 2:4] %>% imap( ~ {

  # define lable function
  give.n <- function(x) {
    return(c(y = median(x) + max(x) / 10, label = round(median(x), 2)))
  }

  # assign colors
  col.ls <-
    setNames(
      c('gray50', 'gray70', 'gray90', "gray" ),
      c("nCount_RNA", "nFeature_RNA", "percent.mt", "log10GenesPerUMI")
    )

  ggplot(data = df, aes(x = orig.ident, y = .x)) +
    geom_violin(trim = FALSE, fill = col.ls[.y]) +
    ggtitle(label = .y) + ylab(label = .y) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_blank(),
      panel.border = element_blank()
    ) +
    theme(
      axis.text = element_text(size = fontsize),
      axis.line = element_line(colour = "black", size = linesize),
      axis.ticks = element_line(size = linesize),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(.05, "cm"),
      plot.title = element_text(size = fontsize + 2, hjust = 0.5),
      legend.position = 'none'
    ) +
    stat_summary(fun = median, geom = "point", col = "black") +  # Add points to plot
    stat_summary(fun.data = give.n,
                 geom = "text",
                 col = "black") + theme_light()
})

grid.arrange(gp.ls[[1]], gp.ls[[2]], gp.ls[[3]], ncol = 3)
```

### Number of cell counts per sample before filtering
```{r, fig.height=4, fig.width=2}
metadata <- HBx01@meta.data
# Add cell IDs to metadata
metadata$cells <- rownames(metadata)

# Rename columns
metadata <- metadata %>%
  dplyr::rename(nUMI = nCount_RNA,
                nGene = nFeature_RNA)

unique(metadata$orig.ident)
# Visualize the number of cell counts per sample
metadata %>%
  ggplot(aes(x=orig.ident, fill=orig.ident)) +
  geom_bar(color = "gray80", fill = "gray80") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells") + theme(legend.position = "none") +
  theme(legend.position = "none") +
  geom_text(stat='count', aes(label=..count..), vjust = 0.5)
```

### Number UMIs/transcripts per cell
```{r, fig.width=4, fig.height=3}
#Visualize the number UMIs/transcripts per cell
ggplot(metadata, aes(x = nUMI)) +
  geom_histogram(aes(y = ..density..),
                 alpha = 0.3, color="gray50", fill="white") +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density/UMI counts per cell") +
  geom_vline(xintercept = 500) + theme(legend.position = "none")+
  geom_density(lwd = 0.5, colour = 4,
               fill = 4, alpha = 0.1)
#The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply
```

### More on Data and QC
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=6}
counts <- Matrix(HBx01@assays$RNA@counts)
counts_per_cell <- Matrix::colSums(counts)
counts_per_gene <- Matrix::rowSums(counts)
genes_per_cell1 <- Matrix::colSums(counts>0) #count a gene only if it has non-zero reads mapped.
cells_per_gene <- Matrix::rowSums(counts>0) #only count cells where the gene is expressed

counts_per_cell <- as.data.frame(colSums(counts))
counts_per_gene <- as.data.frame(rowSums(counts))
genes_per_cell <- as.data.frame(colSums(counts>0))
cells_per_gene <- as.data.frame(rowSums(counts>0) )

colnames(counts_per_cell) <- "counts"
colnames(counts_per_gene) <- "counts"
colnames(genes_per_cell) <- "genes_per_cell"
colnames(cells_per_gene) <- "cells_per_gene"

df <- cbind(counts_per_cell, genes_per_cell)

ggplot(df, aes(x=counts, y=genes_per_cell)) + geom_point(color="gray30") + scale_y_continuous(trans='log10') + scale_x_continuous(trans='log10') + theme_light()

#Plot cells ranked by their number of detected genes.
genes_per_cell$cells <- rownames(genes_per_cell)

#set upper and lower thresholds for genes per cell - the upper and lower limit curve bends give a good clue on what thresholds to set:
min_genes_per_cell <- 200
max_genes_per_cell <- 3500

ggplot(genes_per_cell, aes(x=reorder(genes_per_cell, cells), y=genes_per_cell)) + geom_point() +
  scale_y_continuous(trans='log10', breaks=seq(0, 5000, by = 1000)) + ggtitle("Genes per Cell") + theme_test(base_size = 12) +
  geom_hline(aes(yintercept=min_genes_per_cell),
             color="blue", linetype="dashed", size=0.5) +
  geom_hline(aes(yintercept=max_genes_per_cell), color="blue", linetype="dashed", size=0.5) + labs(x= "Cells", y="Number of Genes") + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
```

### Percent MT Distribution
```{r fig.width=12, fig.height=6}
#Density plot
ggplot(HBx01@meta.data, aes(x=HBx01@meta.data$percent.mt)) +
  geom_density() + scale_color_manual(values=c("blue")) + theme_classic() +
  geom_vline(aes(xintercept=mean(HBx01@meta.data$percent.mt)),
             color="blue", linetype="dashed", size=0.5) +scale_x_continuous(breaks=seq(0, 40, by = 1))
```

### Data Filtering

```{r}
(Count93_nCount_RNA <- quantile(HBx01@meta.data$nCount_RNA, 0.93)) # calculate value in the 93rd percentile for a hint on thresholds but these should be taken with a grain of salt, look at the above plots as well to determine thresholds
(Count93_nFeature_RNA <- quantile(HBx01@meta.data$nFeature_RNA, 0.93))
(Count93_percent_mt <-  quantile(HBx01@meta.data$percent.mt, 0.93))

summary(HBx01@meta.data$nCount_RNA)
summary(HBx01@meta.data$nFeature_RNA)

HBx01 <- subset(HBx01, subset = nFeature_RNA > 200 & nFeature_RNA < 3500 & percent.mt < 8)
```

### Data after filtering based on above thresholds
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx01, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx01, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx01, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(HBx01)
```

## Doublet Removal
Detection of doublets was conducting in python using [scrublet](https://github.com/swolock/scrublet) and a file containing scrublet calls/predictions was written out. This file was then loaded into R to use as a basis for filtering out doublets.

Visualization of the doublet predictions in a 2-D embedding/UAMP. Predicted doublets should mostly co-localize (possibly in multiple clusters). If they do not, you may need to adjust the doublet score threshold, or change the pre-processing parameters to better resolve the cell states present in your data.

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx01/HBx01_doublet_predictions.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

The simulated doublet histogram below should typically be bimodal. The left mode corresponds to "embedded" doublets generated by two cells with similar gene expression. The right mode corresponds to "neotypic" doublets, which are generated by cells with distinct gene expression (e.g., different cell types) and are expected to introduce more artifacts in downstream analyses. Scrublet can only detect neotypic doublets.
This histogram is an important diagnostic plot. Doublet score threshold should separate the two shoulders of the bimodal distribution as shown below:

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx01/HBx01_doublet_predictions_histogram.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

```{r out.height = "460px", out.width='800px', echo=F, eval=FALSE}
knitr::include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx01/HBx01_doublet_predictions_histogram.pdf')
```

```{r}
#Loading scrublet predictions
dim(scrublet_calls <- read.csv("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx01/HBx01_scrublet_calls.csv"))
table(scrublet_calls$predicted_doublets)

scrublet_calls$X <- paste0("Early_Secretory_HBx01_", scrublet_calls$X)

dim(scrublet_calls <- scrublet_calls[which(scrublet_calls$X %in% rownames(HBx01@meta.data)),])
rownames(scrublet_calls) <- scrublet_calls$X
scrublet_calls$X <-NULL
dim(scrublet_calls)

#Adding doublet information to metadata
#First we'll ensure that the rownames in HBx01 match the rownames in scrublet_calls. AddMetaData maps rownames but we'll still do so to ensure that mapping of predictions are made to respective bar codes
scrublet_calls <- scrublet_calls[rownames(HBx01@meta.data), ]
head(rownames(scrublet_calls))
head(rownames(HBx01@meta.data))
HBx01 <- AddMetaData(HBx01, scrublet_calls)
```


```{r, fig.height=4, fig.width=5}
#Without normalizing the data, we want to first visualize the doublets in our datasets
HBx01_Control_2 <- HBx01
HBx01_Control_2 <- FindVariableFeatures(HBx01_Control_2, selection.method = "vst", nfeatures = 2500)
HBx01_Control_2 <- ScaleData(object = HBx01_Control_2, scale.max = 30,  verbose = FALSE)
HBx01_Control_2 <- RunPCA(object = HBx01_Control_2, npcs = 30, verbose = FALSE)
HBx01_Control_2 <- FindNeighbors(HBx01_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
HBx01_Control_2 <- RunUMAP(HBx01_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
HBx01_Control_2 <- FindClusters(HBx01_Control_2, verbose = TRUE, reduction = "pca") #Resolution can be adjusted - leaving to default for now in test dataset

FeaturePlot(HBx01_Control_2, features = "doublet_scores", pt.size = 0.01)

DimPlot(HBx01_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"))

#Checking the nUMI for doublets and singlets
VlnPlot(HBx01_Control_2,
        features = "nCount_RNA",
        pt.size = 0,
        group.by = "predicted_doublets") + NoLegend()

#Fractions of doublets per cluster
df <- data.table(HBx01_Control_2@meta.data)

perc <- as.data.frame(df %>%
                        group_by(seurat_clusters, predicted_doublets) %>%
                        dplyr::summarise(cnt = n()) %>%
                        mutate(freq = formattable::percent(cnt / sum(cnt), digits = 5)))

perc$predicted_doublets <- as.character(perc$predicted_doublets)
perc$predicted_doublets[perc$predicted_doublets == "True"] <- "Doublet"
perc$predicted_doublets[perc$predicted_doublets == "False"] <- "Singlet"
```

```{r, fig.height=3.5, fig.width=7}
perc %>%
  ggplot() +
  geom_bar(aes(x = seurat_clusters, y=freq,
               group = predicted_doublets,
               fill = predicted_doublets),
           stat = "identity", width = 0.99, alpha = 0.9) +
  theme_test()+
  labs(y=paste0("% Distribution of doublets and singlets per cluster"), x="") +
  scale_fill_manual(values = c("Doublet" = 'firebrick4', "Singlet" = "dodgerblue4")) +
  theme(legend.position = "right") +scale_y_continuous(expand = c(0,0))
```

```{r, fig.height=4, fig.width=5}
#Next we'll remove the doublets and see what the data looks like
HBx01_Control_2 <- HBx01_Control_2[, HBx01_Control_2@meta.data[, "predicted_doublets"] == "False"]
unique(HBx01_Control_2@meta.data$predicted_doublets)
DimPlot(HBx01_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"), label = TRUE)
```

**Filtering cells to remove doublets**
```{r}
HBx01 <- HBx01[, HBx01@meta.data[, "predicted_doublets"] == "False"]
unique(HBx01@meta.data$predicted_doublets)
dim(HBx01)
```

### Data after filtering doublets
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx01, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx01, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx01, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(HBx01)
```

### Saving object for further downstream analysis
```{r}
saveRDS(HBx01, file = "/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/QC/HBx01_SeuratObject_soupX_doublet_QC_filtered.rds")
rm(HBx01)
gc()
```



## HBx10 QC

```{r,fig.height=7, fig.width=13}
#We'll store the percentage of reads that map to the mitochondrial genome in the metadata object as "percent.mt"
HBx10[["percent.mt"]] <- PercentageFeatureSet(HBx10, pattern = "^MT-")

#The number of unique genes and total molecules are automatically calculated during `CreateSeuratObject()` and we can find these stored in the object meta data as nFeature_RNA and nCount_RNA respecitvely.
HBx10@meta.data %>%
  head(n=5)
```

**Visualize QC metrics, and use these to filter cells**

```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx10, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx10, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx10, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)
```


```{r, message=FALSE, fig.width=20, fig.height=7}
#FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(HBx10, feature1 = "nCount_RNA", feature2 = "percent.mt", cols = "gray60")
plot2 <- FeatureScatter(HBx10, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", cols = "gray60")
plot1 + plot2
```

**Alternative view of the data and distributions**
```{r, fig.height=3}
df <- as.data.table(HBx10@meta.data)
sel <- c("orig.ident", "nCount_RNA", "nFeature_RNA", "percent.mt")
df <- df[, sel, with = FALSE]
df[1:3, ]
fontsize <- 10
linesize <- 0.35

gp.ls <- df[, 2:4] %>% imap( ~ {

  # define lable function
  give.n <- function(x) {
    return(c(y = median(x) + max(x) / 10, label = round(median(x), 2)))
  }

  # assign colors
  col.ls <-
    setNames(
      c('gray50', 'gray70', 'gray90', "gray" ),
      c("nCount_RNA", "nFeature_RNA", "percent.mt", "log10GenesPerUMI")
    )

  ggplot(data = df, aes(x = orig.ident, y = .x)) +
    geom_violin(trim = FALSE, fill = col.ls[.y]) +
    ggtitle(label = .y) + ylab(label = .y) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_blank(),
      panel.border = element_blank()
    ) +
    theme(
      axis.text = element_text(size = fontsize),
      axis.line = element_line(colour = "black", size = linesize),
      axis.ticks = element_line(size = linesize),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(.05, "cm"),
      plot.title = element_text(size = fontsize + 2, hjust = 0.5),
      legend.position = 'none'
    ) +
    stat_summary(fun = median, geom = "point", col = "black") +  # Add points to plot
    stat_summary(fun.data = give.n,
                 geom = "text",
                 col = "black") + theme_light()
})

grid.arrange(gp.ls[[1]], gp.ls[[2]], gp.ls[[3]], ncol = 3)
```

### Number of cell counts per sample before filtering
```{r, fig.height=4, fig.width=2}
metadata <- HBx10@meta.data
# Add cell IDs to metadata
metadata$cells <- rownames(metadata)

# Rename columns
metadata <- metadata %>%
  dplyr::rename(nUMI = nCount_RNA,
                nGene = nFeature_RNA)

unique(metadata$orig.ident)
# Visualize the number of cell counts per sample
metadata %>%
  ggplot(aes(x=orig.ident, fill=orig.ident)) +
  geom_bar(color = "gray80", fill = "gray80") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells") + theme(legend.position = "none") +
  theme(legend.position = "none") +
  geom_text(stat='count', aes(label=..count..), vjust = 0.5)
```

### Number UMIs/transcripts per cell
```{r, fig.width=4, fig.height=3}
#Visualize the number UMIs/transcripts per cell
ggplot(metadata, aes(x = nUMI)) +
  geom_histogram(aes(y = ..density..),
                 alpha = 0.3, color="gray50", fill="white") +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density/UMI counts per cell") +
  geom_vline(xintercept = 500) + theme(legend.position = "none")+
  geom_density(lwd = 0.5, colour = 4,
               fill = 4, alpha = 0.1)
#The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply
```

### More on Data and QC
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=6}
counts <- Matrix(HBx10@assays$RNA@counts)
counts_per_cell <- Matrix::colSums(counts)
counts_per_gene <- Matrix::rowSums(counts)
genes_per_cell1 <- Matrix::colSums(counts>0) #count a gene only if it has non-zero reads mapped.
cells_per_gene <- Matrix::rowSums(counts>0) #only count cells where the gene is expressed

counts_per_cell <- as.data.frame(colSums(counts))
counts_per_gene <- as.data.frame(rowSums(counts))
genes_per_cell <- as.data.frame(colSums(counts>0))
cells_per_gene <- as.data.frame(rowSums(counts>0) )

colnames(counts_per_cell) <- "counts"
colnames(counts_per_gene) <- "counts"
colnames(genes_per_cell) <- "genes_per_cell"
colnames(cells_per_gene) <- "cells_per_gene"

df <- cbind(counts_per_cell, genes_per_cell)

ggplot(df, aes(x=counts, y=genes_per_cell)) + geom_point(color="gray30") + scale_y_continuous(trans='log10') + scale_x_continuous(trans='log10') + theme_light()

#Plot cells ranked by their number of detected genes.
genes_per_cell$cells <- rownames(genes_per_cell)

#set upper and lower thresholds for genes per cell - the upper and lower limit curve bends give a good clue on what thresholds to set:
min_genes_per_cell <- 200
max_genes_per_cell <- 3500

ggplot(genes_per_cell, aes(x=reorder(genes_per_cell, cells), y=genes_per_cell)) + geom_point() +
  scale_y_continuous(trans='log10', breaks=seq(0, 5000, by = 1000)) + ggtitle("Genes per Cell") + theme_test(base_size = 12) +
  geom_hline(aes(yintercept=min_genes_per_cell),
             color="blue", linetype="dashed", size=0.5) +
  geom_hline(aes(yintercept=max_genes_per_cell), color="blue", linetype="dashed", size=0.5) + labs(x= "Cells", y="Number of Genes") + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
```

### Percent MT Distribution
```{r fig.width=12, fig.height=6}
#Density plot
ggplot(HBx10@meta.data, aes(x=HBx10@meta.data$percent.mt)) +
  geom_density() + scale_color_manual(values=c("blue")) + theme_classic() +
  geom_vline(aes(xintercept=mean(HBx10@meta.data$percent.mt)),
             color="blue", linetype="dashed", size=0.5) +scale_x_continuous(breaks=seq(0, 40, by = 1))
```

### Data Filtering


```{r}
(Count93_nCount_RNA <- quantile(HBx10@meta.data$nCount_RNA, 0.93)) # calculate value in the 93rd percentile for a hint on thresholds but these should be taken with a grain of salt, look at the above plots as well to determine thresholds
(Count93_nFeature_RNA <- quantile(HBx10@meta.data$nFeature_RNA, 0.93))
(Count93_percent_mt <-  quantile(HBx10@meta.data$percent.mt, 0.93))

summary(HBx10@meta.data$nCount_RNA)
summary(HBx10@meta.data$nFeature_RNA)

HBx10 <- subset(HBx10, subset = nFeature_RNA > 200 & nFeature_RNA < 3500 & percent.mt < 9)
```

### Data after filtering based on above thresholds
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx10, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx10, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx10, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(HBx10)
```

## Doublet Removal
Detection of doublets was conducting in python using [scrublet](https://github.com/swolock/scrublet) and a file containing scrublet calls/predictions was written out. This file was then loaded into R to use as a basis for filtering out doublets.

Visualization of the doublet predictions in a 2-D embedding/UAMP. Predicted doublets should mostly co-localize (possibly in multiple clusters). If they do not, you may need to adjust the doublet score threshold, or change the pre-processing parameters to better resolve the cell states present in your data.

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx10/HBx10_doublet_predictions.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

The simulated doublet histogram below should typically be bimodal. The left mode corresponds to "embedded" doublets generated by two cells with similar gene expression. The right mode corresponds to "neotypic" doublets, which are generated by cells with distinct gene expression (e.g., different cell types) and are expected to introduce more artifacts in downstream analyses. Scrublet can only detect neotypic doublets.
This histogram is an important diagnostic plot. Doublet score threshold should separate the two shoulders of the bimodal distribution as shown below:

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx10/HBx10_doublet_predictions_histogram.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

```{r out.height = "460px", out.width='800px', echo=F, eval=FALSE}
knitr::include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx10/HBx10_doublet_predictions_histogram.pdf')
```

```{r}
#Loading scrublet predictions
dim(scrublet_calls <- read.csv("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx10/HBx10_scrublet_calls.csv"))
table(scrublet_calls$predicted_doublets)

scrublet_calls$X <- paste0("Mid_Secretory_HBx10_", scrublet_calls$X)

dim(scrublet_calls <- scrublet_calls[which(scrublet_calls$X %in% rownames(HBx10@meta.data)),])
rownames(scrublet_calls) <- scrublet_calls$X
scrublet_calls$X <-NULL
dim(scrublet_calls)

#Adding doublet information to metadata
#First we'll ensure that the rownames in HBx10 match the rownames in scrublet_calls. AddMetaData maps rownames but we'll still do so to ensure that mapping of predictions are made to respective bar codes
scrublet_calls <- scrublet_calls[rownames(HBx10@meta.data), ]
head(rownames(scrublet_calls))
head(rownames(HBx10@meta.data))
HBx10 <- AddMetaData(HBx10, scrublet_calls)
```


```{r, fig.height=4, fig.width=5}
#Without normalizing the data, we want to first visualize the doublets in our datasets
HBx10_Control_2 <- HBx10
HBx10_Control_2 <- FindVariableFeatures(HBx10_Control_2, selection.method = "vst", nfeatures = 2500)
HBx10_Control_2 <- ScaleData(object = HBx10_Control_2, scale.max = 30,  verbose = FALSE)
HBx10_Control_2 <- RunPCA(object = HBx10_Control_2, npcs = 30, verbose = FALSE)
HBx10_Control_2 <- FindNeighbors(HBx10_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
HBx10_Control_2 <- RunUMAP(HBx10_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
HBx10_Control_2 <- FindClusters(HBx10_Control_2, verbose = TRUE, reduction = "pca") #Resolution can be adjusted - leaving to default for now in test dataset

FeaturePlot(HBx10_Control_2, features = "doublet_scores", pt.size = 0.01)

DimPlot(HBx10_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"))

#Checking the nUMI for doublets and singlets
VlnPlot(HBx10_Control_2,
        features = "nCount_RNA",
        pt.size = 0,
        group.by = "predicted_doublets") + NoLegend()

#Fractions of doublets per cluster
df <- data.table(HBx10_Control_2@meta.data)

perc <- as.data.frame(df %>%
                        group_by(seurat_clusters, predicted_doublets) %>%
                        dplyr::summarise(cnt = n()) %>%
                        mutate(freq = formattable::percent(cnt / sum(cnt), digits = 5)))

perc$predicted_doublets <- as.character(perc$predicted_doublets)
perc$predicted_doublets[perc$predicted_doublets == "True"] <- "Doublet"
perc$predicted_doublets[perc$predicted_doublets == "False"] <- "Singlet"
```

```{r, fig.height=3.5, fig.width=7}
perc %>%
  ggplot() +
  geom_bar(aes(x = seurat_clusters, y=freq,
               group = predicted_doublets,
               fill = predicted_doublets),
           stat = "identity", width = 0.99, alpha = 0.9) +
  theme_test()+
  labs(y=paste0("% Distribution of doublets and singlets per cluster"), x="") +
  scale_fill_manual(values = c("Doublet" = 'firebrick4', "Singlet" = "dodgerblue4")) +
  theme(legend.position = "right") +scale_y_continuous(expand = c(0,0))
```

```{r, fig.height=4, fig.width=5}
#Next we'll remove the doublets and see what the data looks like
HBx10_Control_2 <- HBx10_Control_2[, HBx10_Control_2@meta.data[, "predicted_doublets"] == "False"]
unique(HBx10_Control_2@meta.data$predicted_doublets)
DimPlot(HBx10_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"), label = TRUE)
```

**Filtering cells to remove doublets**
```{r}
HBx10 <- HBx10[, HBx10@meta.data[, "predicted_doublets"] == "False"]
unique(HBx10@meta.data$predicted_doublets)
dim(HBx10)
```

### Data after filtering doublets
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx10, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx10, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx10, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(HBx10)
```

### Saving object for further downstream analysis
```{r}
saveRDS(HBx10, file = "/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/QC/HBx10_SeuratObject_soupX_doublet_QC_filtered.rds")
rm(HBx10)
gc()
```


## HBx12 QC

```{r,fig.height=7, fig.width=13}
#We'll store the percentage of reads that map to the mitochondrial genome in the metadata object as "percent.mt"
HBx12[["percent.mt"]] <- PercentageFeatureSet(HBx12, pattern = "^MT-")

#The number of unique genes and total molecules are automatically calculated during `CreateSeuratObject()` and we can find these stored in the object meta data as nFeature_RNA and nCount_RNA respecitvely.
HBx12@meta.data %>%
  head(n=5)
```

**Visualize QC metrics, and use these to filter cells**

```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx12, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx12, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx12, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)
```


```{r, message=FALSE, fig.width=20, fig.height=7}
#FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(HBx12, feature1 = "nCount_RNA", feature2 = "percent.mt", cols = "gray60")
plot2 <- FeatureScatter(HBx12, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", cols = "gray60")
plot1 + plot2
```

**Alternative view of the data and distributions**
```{r, fig.height=3}
df <- as.data.table(HBx12@meta.data)
sel <- c("orig.ident", "nCount_RNA", "nFeature_RNA", "percent.mt")
df <- df[, sel, with = FALSE]
df[1:3, ]
fontsize <- 10
linesize <- 0.35

gp.ls <- df[, 2:4] %>% imap( ~ {

  # define lable function
  give.n <- function(x) {
    return(c(y = median(x) + max(x) / 10, label = round(median(x), 2)))
  }

  # assign colors
  col.ls <-
    setNames(
      c('gray50', 'gray70', 'gray90', "gray" ),
      c("nCount_RNA", "nFeature_RNA", "percent.mt", "log10GenesPerUMI")
    )

  ggplot(data = df, aes(x = orig.ident, y = .x)) +
    geom_violin(trim = FALSE, fill = col.ls[.y]) +
    ggtitle(label = .y) + ylab(label = .y) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_blank(),
      panel.border = element_blank()
    ) +
    theme(
      axis.text = element_text(size = fontsize),
      axis.line = element_line(colour = "black", size = linesize),
      axis.ticks = element_line(size = linesize),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(.05, "cm"),
      plot.title = element_text(size = fontsize + 2, hjust = 0.5),
      legend.position = 'none'
    ) +
    stat_summary(fun = median, geom = "point", col = "black") +  # Add points to plot
    stat_summary(fun.data = give.n,
                 geom = "text",
                 col = "black") + theme_light()
})

grid.arrange(gp.ls[[1]], gp.ls[[2]], gp.ls[[3]], ncol = 3)
```

### Number of cell counts per sample before filtering
```{r, fig.height=4, fig.width=2}
metadata <- HBx12@meta.data
# Add cell IDs to metadata
metadata$cells <- rownames(metadata)

# Rename columns
metadata <- metadata %>%
  dplyr::rename(nUMI = nCount_RNA,
                nGene = nFeature_RNA)

unique(metadata$orig.ident)
# Visualize the number of cell counts per sample
metadata %>%
  ggplot(aes(x=orig.ident, fill=orig.ident)) +
  geom_bar(color = "gray80", fill = "gray80") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells") + theme(legend.position = "none") +
  theme(legend.position = "none") +
  geom_text(stat='count', aes(label=..count..), vjust = 0.5)
```

### Number UMIs/transcripts per cell
```{r, fig.width=4, fig.height=3}
#Visualize the number UMIs/transcripts per cell
ggplot(metadata, aes(x = nUMI)) +
  geom_histogram(aes(y = ..density..),
                 alpha = 0.3, color="gray50", fill="white") +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density/UMI counts per cell") +
  geom_vline(xintercept = 500) + theme(legend.position = "none")+
  geom_density(lwd = 0.5, colour = 4,
               fill = 4, alpha = 0.1)
#The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply
```

### More on Data and QC
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=6}
counts <- Matrix(HBx12@assays$RNA@counts)
counts_per_cell <- Matrix::colSums(counts)
counts_per_gene <- Matrix::rowSums(counts)
genes_per_cell1 <- Matrix::colSums(counts>0) #count a gene only if it has non-zero reads mapped.
cells_per_gene <- Matrix::rowSums(counts>0) #only count cells where the gene is expressed

counts_per_cell <- as.data.frame(colSums(counts))
counts_per_gene <- as.data.frame(rowSums(counts))
genes_per_cell <- as.data.frame(colSums(counts>0))
cells_per_gene <- as.data.frame(rowSums(counts>0) )

colnames(counts_per_cell) <- "counts"
colnames(counts_per_gene) <- "counts"
colnames(genes_per_cell) <- "genes_per_cell"
colnames(cells_per_gene) <- "cells_per_gene"

df <- cbind(counts_per_cell, genes_per_cell)

ggplot(df, aes(x=counts, y=genes_per_cell)) + geom_point(color="gray30") + scale_y_continuous(trans='log10') + scale_x_continuous(trans='log10') + theme_light()

#Plot cells ranked by their number of detected genes.
genes_per_cell$cells <- rownames(genes_per_cell)

#set upper and lower thresholds for genes per cell - the upper and lower limit curve bends give a good clue on what thresholds to set:
min_genes_per_cell <- 200
max_genes_per_cell <- 4000

ggplot(genes_per_cell, aes(x=reorder(genes_per_cell, cells), y=genes_per_cell)) + geom_point() +
  scale_y_continuous(trans='log10', breaks=seq(0, 5000, by = 1000)) + ggtitle("Genes per Cell") + theme_test(base_size = 12) +
  geom_hline(aes(yintercept=min_genes_per_cell),
             color="blue", linetype="dashed", size=0.5) +
  geom_hline(aes(yintercept=max_genes_per_cell), color="blue", linetype="dashed", size=0.5) + labs(x= "Cells", y="Number of Genes") + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
```

### Percent MT Distribution
```{r fig.width=12, fig.height=6}
#Density plot
ggplot(HBx12@meta.data, aes(x=HBx12@meta.data$percent.mt)) +
  geom_density() + scale_color_manual(values=c("blue")) + theme_classic() +
  geom_vline(aes(xintercept=mean(HBx12@meta.data$percent.mt)),
             color="blue", linetype="dashed", size=0.5) +scale_x_continuous(breaks=seq(0, 40, by = 1))
```

### Data Filtering

```{r}
(Count93_nCount_RNA <- quantile(HBx12@meta.data$nCount_RNA, 0.93)) # calculate value in the 93rd percentile for a hint on thresholds but these should be taken with a grain of salt, look at the above plots as well to determine thresholds
(Count93_nFeature_RNA <- quantile(HBx12@meta.data$nFeature_RNA, 0.93))
(Count93_percent_mt <-  quantile(HBx12@meta.data$percent.mt, 0.93))

summary(HBx12@meta.data$nCount_RNA)
summary(HBx12@meta.data$nFeature_RNA)

HBx12 <- subset(HBx12, subset = nFeature_RNA > 200 & nFeature_RNA < 4000 & percent.mt < 12)
```

### Data after filtering based on above thresholds
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx12, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx12, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx12, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(HBx12)
```

## Doublet Removal
Detection of doublets was conducting in python using [scrublet](https://github.com/swolock/scrublet) and a file containing scrublet calls/predictions was written out. This file was then loaded into R to use as a basis for filtering out doublets.

Visualization of the doublet predictions in a 2-D embedding/UAMP. Predicted doublets should mostly co-localize (possibly in multiple clusters). If they do not, you may need to adjust the doublet score threshold, or change the pre-processing parameters to better resolve the cell states present in your data.

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx12/HBx12_doublet_predictions.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

The simulated doublet histogram below should typically be bimodal. The left mode corresponds to "embedded" doublets generated by two cells with similar gene expression. The right mode corresponds to "neotypic" doublets, which are generated by cells with distinct gene expression (e.g., different cell types) and are expected to introduce more artifacts in downstream analyses. Scrublet can only detect neotypic doublets.
This histogram is an important diagnostic plot. Doublet score threshold should separate the two shoulders of the bimodal distribution as shown below:

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx12/HBx12_doublet_predictions_histogram.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

```{r out.height = "460px", out.width='800px', echo=F, eval=FALSE}
knitr::include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx12/HBx12_doublet_predictions_histogram.pdf')
```

```{r}
#Loading scrublet predictions
dim(scrublet_calls <- read.csv("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx12/HBx12_scrublet_calls.csv"))
table(scrublet_calls$predicted_doublets)

scrublet_calls$X <- paste0("Mid_Secretory_HBx12_", scrublet_calls$X)

dim(scrublet_calls <- scrublet_calls[which(scrublet_calls$X %in% rownames(HBx12@meta.data)),])
rownames(scrublet_calls) <- scrublet_calls$X
scrublet_calls$X <-NULL
dim(scrublet_calls)

#Adding doublet information to metadata
#First we'll ensure that the rownames in HBx12 match the rownames in scrublet_calls. AddMetaData maps rownames but we'll still do so to ensure that mapping of predictions are made to respective bar codes
scrublet_calls <- scrublet_calls[rownames(HBx12@meta.data), ]
head(rownames(scrublet_calls))
head(rownames(HBx12@meta.data))
HBx12 <- AddMetaData(HBx12, scrublet_calls)
```


```{r, fig.height=4, fig.width=5}
#Without normalizing the data, we want to first visualize the doublets in our datasets
HBx12_Control_2 <- HBx12
HBx12_Control_2 <- FindVariableFeatures(HBx12_Control_2, selection.method = "vst", nfeatures = 2500)
HBx12_Control_2 <- ScaleData(object = HBx12_Control_2, scale.max = 30,  verbose = FALSE)
HBx12_Control_2 <- RunPCA(object = HBx12_Control_2, npcs = 30, verbose = FALSE)
HBx12_Control_2 <- FindNeighbors(HBx12_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
HBx12_Control_2 <- RunUMAP(HBx12_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
HBx12_Control_2 <- FindClusters(HBx12_Control_2, verbose = TRUE, reduction = "pca") #Resolution can be adjusted - leaving to default for now in test dataset

FeaturePlot(HBx12_Control_2, features = "doublet_scores", pt.size = 0.01)

DimPlot(HBx12_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"))

#Checking the nUMI for doublets and singlets
VlnPlot(HBx12_Control_2,
        features = "nCount_RNA",
        pt.size = 0,
        group.by = "predicted_doublets") + NoLegend()

#Fractions of doublets per cluster
df <- data.table(HBx12_Control_2@meta.data)

perc <- as.data.frame(df %>%
                        group_by(seurat_clusters, predicted_doublets) %>%
                        dplyr::summarise(cnt = n()) %>%
                        mutate(freq = formattable::percent(cnt / sum(cnt), digits = 5)))

perc$predicted_doublets <- as.character(perc$predicted_doublets)
perc$predicted_doublets[perc$predicted_doublets == "True"] <- "Doublet"
perc$predicted_doublets[perc$predicted_doublets == "False"] <- "Singlet"
```

```{r, fig.height=3.5, fig.width=7}
perc %>%
  ggplot() +
  geom_bar(aes(x = seurat_clusters, y=freq,
               group = predicted_doublets,
               fill = predicted_doublets),
           stat = "identity", width = 0.99, alpha = 0.9) +
  theme_test()+
  labs(y=paste0("% Distribution of doublets and singlets per cluster"), x="") +
  scale_fill_manual(values = c("Doublet" = 'firebrick4', "Singlet" = "dodgerblue4")) +
  theme(legend.position = "right") +scale_y_continuous(expand = c(0,0))
```

```{r, fig.height=4, fig.width=5}
#Next we'll remove the doublets and see what the data looks like
HBx12_Control_2 <- HBx12_Control_2[, HBx12_Control_2@meta.data[, "predicted_doublets"] == "False"]
unique(HBx12_Control_2@meta.data$predicted_doublets)
DimPlot(HBx12_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"), label = TRUE)
```

**Filtering cells to remove doublets**
```{r}
HBx12 <- HBx12[, HBx12@meta.data[, "predicted_doublets"] == "False"]
unique(HBx12@meta.data$predicted_doublets)
dim(HBx12)
```

### Data after filtering doublets
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx12, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx12, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx12, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(HBx12)
```

### Saving object for further downstream analysis
```{r}
saveRDS(HBx12, file = "/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/QC/HBx12_SeuratObject_soupX_doublet_QC_filtered.rds")
rm(HBx12)
gc()
```


## HBx18_CD45 QC

```{r,fig.height=7, fig.width=13}
#We'll store the percentage of reads that map to the mitochondrial genome in the metadata object as "percent.mt"
HBx18_CD45[["percent.mt"]] <- PercentageFeatureSet(HBx18_CD45, pattern = "^MT-")

#The number of unique genes and total molecules are automatically calculated during `CreateSeuratObject()` and we can find these stored in the object meta data as nFeature_RNA and nCount_RNA respecitvely.
HBx18_CD45@meta.data %>%
  head(n=5)
```

**Visualize QC metrics, and use these to filter cells**

```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx18_CD45, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx18_CD45, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx18_CD45, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)
```


```{r, message=FALSE, fig.width=20, fig.height=7}
#FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(HBx18_CD45, feature1 = "nCount_RNA", feature2 = "percent.mt", cols = "gray60")
plot2 <- FeatureScatter(HBx18_CD45, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", cols = "gray60")
plot1 + plot2
```

**Alternative view of the data and distributions**
```{r, fig.height=3}
df <- as.data.table(HBx18_CD45@meta.data)
sel <- c("orig.ident", "nCount_RNA", "nFeature_RNA", "percent.mt")
df <- df[, sel, with = FALSE]
df[1:3, ]
fontsize <- 10
linesize <- 0.35

gp.ls <- df[, 2:4] %>% imap( ~ {

  # define lable function
  give.n <- function(x) {
    return(c(y = median(x) + max(x) / 10, label = round(median(x), 2)))
  }

  # assign colors
  col.ls <-
    setNames(
      c('gray50', 'gray70', 'gray90', "gray" ),
      c("nCount_RNA", "nFeature_RNA", "percent.mt", "log10GenesPerUMI")
    )

  ggplot(data = df, aes(x = orig.ident, y = .x)) +
    geom_violin(trim = FALSE, fill = col.ls[.y]) +
    ggtitle(label = .y) + ylab(label = .y) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_blank(),
      panel.border = element_blank()
    ) +
    theme(
      axis.text = element_text(size = fontsize),
      axis.line = element_line(colour = "black", size = linesize),
      axis.ticks = element_line(size = linesize),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(.05, "cm"),
      plot.title = element_text(size = fontsize + 2, hjust = 0.5),
      legend.position = 'none'
    ) +
    stat_summary(fun = median, geom = "point", col = "black") +  # Add points to plot
    stat_summary(fun.data = give.n,
                 geom = "text",
                 col = "black") + theme_light()
})

grid.arrange(gp.ls[[1]], gp.ls[[2]], gp.ls[[3]], ncol = 3)
```

### Number of cell counts per sample before filtering
```{r, fig.height=4, fig.width=2}
metadata <- HBx18_CD45@meta.data
# Add cell IDs to metadata
metadata$cells <- rownames(metadata)

# Rename columns
metadata <- metadata %>%
  dplyr::rename(nUMI = nCount_RNA,
                nGene = nFeature_RNA)

unique(metadata$orig.ident)
# Visualize the number of cell counts per sample
metadata %>%
  ggplot(aes(x=orig.ident, fill=orig.ident)) +
  geom_bar(color = "gray80", fill = "gray80") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells") + theme(legend.position = "none") +
  theme(legend.position = "none") +
  geom_text(stat='count', aes(label=..count..), vjust = 0.5)
```

### Number UMIs/transcripts per cell
```{r, fig.width=4, fig.height=3}
#Visualize the number UMIs/transcripts per cell
ggplot(metadata, aes(x = nUMI)) +
  geom_histogram(aes(y = ..density..),
                 alpha = 0.3, color="gray50", fill="white") +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density/UMI counts per cell") +
  geom_vline(xintercept = 500) + theme(legend.position = "none")+
  geom_density(lwd = 0.5, colour = 4,
               fill = 4, alpha = 0.1)
#The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply
```

### More on Data and QC
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=6}
counts <- Matrix(HBx18_CD45@assays$RNA@counts)
counts_per_cell <- Matrix::colSums(counts)
counts_per_gene <- Matrix::rowSums(counts)
genes_per_cell1 <- Matrix::colSums(counts>0) #count a gene only if it has non-zero reads mapped.
cells_per_gene <- Matrix::rowSums(counts>0) #only count cells where the gene is expressed

counts_per_cell <- as.data.frame(colSums(counts))
counts_per_gene <- as.data.frame(rowSums(counts))
genes_per_cell <- as.data.frame(colSums(counts>0))
cells_per_gene <- as.data.frame(rowSums(counts>0) )

colnames(counts_per_cell) <- "counts"
colnames(counts_per_gene) <- "counts"
colnames(genes_per_cell) <- "genes_per_cell"
colnames(cells_per_gene) <- "cells_per_gene"

df <- cbind(counts_per_cell, genes_per_cell)

ggplot(df, aes(x=counts, y=genes_per_cell)) + geom_point(color="gray30") + scale_y_continuous(trans='log10') + scale_x_continuous(trans='log10') + theme_light()

#Plot cells ranked by their number of detected genes.
genes_per_cell$cells <- rownames(genes_per_cell)

#set upper and lower thresholds for genes per cell - the upper and lower limit curve bends give a good clue on what thresholds to set:
min_genes_per_cell <- 200
max_genes_per_cell <- 3500

ggplot(genes_per_cell, aes(x=reorder(genes_per_cell, cells), y=genes_per_cell)) + geom_point() +
  scale_y_continuous(trans='log10', breaks=seq(0, 5000, by = 1000)) + ggtitle("Genes per Cell") + theme_test(base_size = 12) +
  geom_hline(aes(yintercept=min_genes_per_cell),
             color="blue", linetype="dashed", size=0.5) +
  geom_hline(aes(yintercept=max_genes_per_cell), color="blue", linetype="dashed", size=0.5) + labs(x= "Cells", y="Number of Genes") + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
```

### Percent MT Distribution
```{r fig.width=12, fig.height=6}
#Density plot
ggplot(HBx18_CD45@meta.data, aes(x=HBx18_CD45@meta.data$percent.mt)) +
  geom_density() + scale_color_manual(values=c("blue")) + theme_classic() +
  geom_vline(aes(xintercept=mean(HBx18_CD45@meta.data$percent.mt)),
             color="blue", linetype="dashed", size=0.5) +scale_x_continuous(breaks=seq(0, 40, by = 1))
```

### Data Filtering

```{r}
(Count93_nCount_RNA <- quantile(HBx18_CD45@meta.data$nCount_RNA, 0.93)) # calculate value in the 93rd percentile for a hint on thresholds but these should be taken with a grain of salt, look at the above plots as well to determine thresholds
(Count93_nFeature_RNA <- quantile(HBx18_CD45@meta.data$nFeature_RNA, 0.93))
(Count93_percent_mt <-  quantile(HBx18_CD45@meta.data$percent.mt, 0.93))

summary(HBx18_CD45@meta.data$nCount_RNA)
summary(HBx18_CD45@meta.data$nFeature_RNA)

HBx18_CD45 <- subset(HBx18_CD45, subset = nFeature_RNA > 200 & nFeature_RNA < 3000 & percent.mt < 14)
```

### Data after filtering based on above thresholds
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx18_CD45, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx18_CD45, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx18_CD45, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(HBx18_CD45)
```

## Doublet Removal
Detection of doublets was conducting in python using [scrublet](https://github.com/swolock/scrublet) and a file containing scrublet calls/predictions was written out. This file was then loaded into R to use as a basis for filtering out doublets.

Visualization of the doublet predictions in a 2-D embedding/UAMP. Predicted doublets should mostly co-localize (possibly in multiple clusters). If they do not, you may need to adjust the doublet score threshold, or change the pre-processing parameters to better resolve the cell states present in your data.

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx18_CD45/HBx18_CD45_doublet_predictions.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

The simulated doublet histogram below should typically be bimodal. The left mode corresponds to "embedded" doublets generated by two cells with similar gene expression. The right mode corresponds to "neotypic" doublets, which are generated by cells with distinct gene expression (e.g., different cell types) and are expected to introduce more artifacts in downstream analyses. Scrublet can only detect neotypic doublets.
This histogram is an important diagnostic plot. Doublet score threshold should separate the two shoulders of the bimodal distribution as shown below:

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx18_CD45/HBx18_CD45_doublet_predictions_histogram.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

```{r out.height = "460px", out.width='800px', echo=F, eval=FALSE}
knitr::include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx18_CD45/HBx18_CD45_doublet_predictions_histogram.pdf')
```

```{r}
#Loading scrublet predictions
dim(scrublet_calls <- read.csv("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx18_CD45/HBx18_CD45_scrublet_calls.csv"))
table(scrublet_calls$predicted_doublets)

scrublet_calls$X <- paste0("Early_Secretory_HBx18_CD45_", scrublet_calls$X)

dim(scrublet_calls <- scrublet_calls[which(scrublet_calls$X %in% rownames(HBx18_CD45@meta.data)),])
rownames(scrublet_calls) <- scrublet_calls$X
scrublet_calls$X <-NULL
dim(scrublet_calls)

#Adding doublet information to metadata
#First we'll ensure that the rownames in HBx18_CD45 match the rownames in scrublet_calls. AddMetaData maps rownames but we'll still do so to ensure that mapping of predictions are made to respective bar codes
scrublet_calls <- scrublet_calls[rownames(HBx18_CD45@meta.data), ]
head(rownames(scrublet_calls))
head(rownames(HBx18_CD45@meta.data))
HBx18_CD45 <- AddMetaData(HBx18_CD45, scrublet_calls)
```


```{r, fig.height=4, fig.width=5}
#Without normalizing the data, we want to first visualize the doublets in our datasets
HBx18_CD45_Control_2 <- HBx18_CD45
HBx18_CD45_Control_2 <- FindVariableFeatures(HBx18_CD45_Control_2, selection.method = "vst", nfeatures = 2500)
HBx18_CD45_Control_2 <- ScaleData(object = HBx18_CD45_Control_2, scale.max = 30,  verbose = FALSE)
HBx18_CD45_Control_2 <- RunPCA(object = HBx18_CD45_Control_2, npcs = 30, verbose = FALSE)
HBx18_CD45_Control_2 <- FindNeighbors(HBx18_CD45_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
HBx18_CD45_Control_2 <- RunUMAP(HBx18_CD45_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
HBx18_CD45_Control_2 <- FindClusters(HBx18_CD45_Control_2, verbose = TRUE, reduction = "pca") #Resolution can be adjusted - leaving to default for now in test dataset

FeaturePlot(HBx18_CD45_Control_2, features = "doublet_scores", pt.size = 0.01)

DimPlot(HBx18_CD45_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"))

#Checking the nUMI for doublets and singlets
VlnPlot(HBx18_CD45_Control_2,
        features = "nCount_RNA",
        pt.size = 0,
        group.by = "predicted_doublets") + NoLegend()

#Fractions of doublets per cluster
df <- data.table(HBx18_CD45_Control_2@meta.data)

perc <- as.data.frame(df %>%
                        group_by(seurat_clusters, predicted_doublets) %>%
                        dplyr::summarise(cnt = n()) %>%
                        mutate(freq = formattable::percent(cnt / sum(cnt), digits = 5)))

perc$predicted_doublets <- as.character(perc$predicted_doublets)
perc$predicted_doublets[perc$predicted_doublets == "True"] <- "Doublet"
perc$predicted_doublets[perc$predicted_doublets == "False"] <- "Singlet"
```

```{r, fig.height=3.5, fig.width=7}
perc %>%
  ggplot() +
  geom_bar(aes(x = seurat_clusters, y=freq,
               group = predicted_doublets,
               fill = predicted_doublets),
           stat = "identity", width = 0.99, alpha = 0.9) +
  theme_test()+
  labs(y=paste0("% Distribution of doublets and singlets per cluster"), x="") +
  scale_fill_manual(values = c("Doublet" = 'firebrick4', "Singlet" = "dodgerblue4")) +
  theme(legend.position = "right") +scale_y_continuous(expand = c(0,0))
```

```{r, fig.height=4, fig.width=5}
#Next we'll remove the doublets and see what the data looks like
HBx18_CD45_Control_2 <- HBx18_CD45_Control_2[, HBx18_CD45_Control_2@meta.data[, "predicted_doublets"] == "False"]
unique(HBx18_CD45_Control_2@meta.data$predicted_doublets)
DimPlot(HBx18_CD45_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"), label = TRUE)
```

**Filtering cells to remove doublets**
```{r}
HBx18_CD45 <- HBx18_CD45[, HBx18_CD45@meta.data[, "predicted_doublets"] == "False"]
unique(HBx18_CD45@meta.data$predicted_doublets)
dim(HBx18_CD45)
```

### Data after filtering doublets
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx18_CD45, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx18_CD45, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx18_CD45, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(HBx18_CD45)
```

### Saving object for further downstream analysis
```{r}
saveRDS(HBx18_CD45, file = "/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/QC/HBx18_CD45_SeuratObject_soupX_doublet_QC_filtered.rds")
rm(HBx18_CD45)
gc()
```



## HBx19 QC

```{r,fig.height=7, fig.width=13}
#We'll store the percentage of reads that map to the mitochondrial genome in the metadata object as "percent.mt"
HBx19[["percent.mt"]] <- PercentageFeatureSet(HBx19, pattern = "^MT-")

#The number of unique genes and total molecules are automatically calculated during `CreateSeuratObject()` and we can find these stored in the object meta data as nFeature_RNA and nCount_RNA respecitvely.
HBx19@meta.data %>%
  head(n=5)
```

**Visualize QC metrics, and use these to filter cells**

```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx19, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx19, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx19, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)
```


```{r, message=FALSE, fig.width=20, fig.height=7}
#FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(HBx19, feature1 = "nCount_RNA", feature2 = "percent.mt", cols = "gray60")
plot2 <- FeatureScatter(HBx19, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", cols = "gray60")
plot1 + plot2
```

**Alternative view of the data and distributions**
```{r, fig.height=3}
df <- as.data.table(HBx19@meta.data)
sel <- c("orig.ident", "nCount_RNA", "nFeature_RNA", "percent.mt")
df <- df[, sel, with = FALSE]
df[1:3, ]
fontsize <- 10
linesize <- 0.35

gp.ls <- df[, 2:4] %>% imap( ~ {

  # define lable function
  give.n <- function(x) {
    return(c(y = median(x) + max(x) / 10, label = round(median(x), 2)))
  }

  # assign colors
  col.ls <-
    setNames(
      c('gray50', 'gray70', 'gray90', "gray" ),
      c("nCount_RNA", "nFeature_RNA", "percent.mt", "log10GenesPerUMI")
    )

  ggplot(data = df, aes(x = orig.ident, y = .x)) +
    geom_violin(trim = FALSE, fill = col.ls[.y]) +
    ggtitle(label = .y) + ylab(label = .y) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_blank(),
      panel.border = element_blank()
    ) +
    theme(
      axis.text = element_text(size = fontsize),
      axis.line = element_line(colour = "black", size = linesize),
      axis.ticks = element_line(size = linesize),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(.05, "cm"),
      plot.title = element_text(size = fontsize + 2, hjust = 0.5),
      legend.position = 'none'
    ) +
    stat_summary(fun = median, geom = "point", col = "black") +  # Add points to plot
    stat_summary(fun.data = give.n,
                 geom = "text",
                 col = "black") + theme_light()
})

grid.arrange(gp.ls[[1]], gp.ls[[2]], gp.ls[[3]], ncol = 3)
```

### Number of cell counts per sample before filtering
```{r, fig.height=4, fig.width=2}
metadata <- HBx19@meta.data
# Add cell IDs to metadata
metadata$cells <- rownames(metadata)

# Rename columns
metadata <- metadata %>%
  dplyr::rename(nUMI = nCount_RNA,
                nGene = nFeature_RNA)

unique(metadata$orig.ident)
# Visualize the number of cell counts per sample
metadata %>%
  ggplot(aes(x=orig.ident, fill=orig.ident)) +
  geom_bar(color = "gray80", fill = "gray80") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells") + theme(legend.position = "none") +
  theme(legend.position = "none") +
  geom_text(stat='count', aes(label=..count..), vjust = 0.5)
```

### Number UMIs/transcripts per cell
```{r, fig.width=4, fig.height=3}
#Visualize the number UMIs/transcripts per cell
ggplot(metadata, aes(x = nUMI)) +
  geom_histogram(aes(y = ..density..),
                 alpha = 0.3, color="gray50", fill="white") +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density/UMI counts per cell") +
  geom_vline(xintercept = 500) + theme(legend.position = "none")+
  geom_density(lwd = 0.5, colour = 4,
               fill = 4, alpha = 0.1)
#The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply
```

### More on Data and QC
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=6}
counts <- Matrix(HBx19@assays$RNA@counts)
counts_per_cell <- Matrix::colSums(counts)
counts_per_gene <- Matrix::rowSums(counts)
genes_per_cell1 <- Matrix::colSums(counts>0) #count a gene only if it has non-zero reads mapped.
cells_per_gene <- Matrix::rowSums(counts>0) #only count cells where the gene is expressed

counts_per_cell <- as.data.frame(colSums(counts))
counts_per_gene <- as.data.frame(rowSums(counts))
genes_per_cell <- as.data.frame(colSums(counts>0))
cells_per_gene <- as.data.frame(rowSums(counts>0) )

colnames(counts_per_cell) <- "counts"
colnames(counts_per_gene) <- "counts"
colnames(genes_per_cell) <- "genes_per_cell"
colnames(cells_per_gene) <- "cells_per_gene"

df <- cbind(counts_per_cell, genes_per_cell)

ggplot(df, aes(x=counts, y=genes_per_cell)) + geom_point(color="gray30") + scale_y_continuous(trans='log10') + scale_x_continuous(trans='log10') + theme_light()

#Plot cells ranked by their number of detected genes.
genes_per_cell$cells <- rownames(genes_per_cell)

#set upper and lower thresholds for genes per cell - the upper and lower limit curve bends give a good clue on what thresholds to set:
min_genes_per_cell <- 200
max_genes_per_cell <- 4000

ggplot(genes_per_cell, aes(x=reorder(genes_per_cell, cells), y=genes_per_cell)) + geom_point() +
  scale_y_continuous(trans='log10', breaks=seq(0, 5000, by = 1000)) + ggtitle("Genes per Cell") + theme_test(base_size = 12) +
  geom_hline(aes(yintercept=min_genes_per_cell),
             color="blue", linetype="dashed", size=0.5) +
  geom_hline(aes(yintercept=max_genes_per_cell), color="blue", linetype="dashed", size=0.5) + labs(x= "Cells", y="Number of Genes") + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
```

### Percent MT Distribution
```{r fig.width=12, fig.height=6}
#Density plot
ggplot(HBx19@meta.data, aes(x=HBx19@meta.data$percent.mt)) +
  geom_density() + scale_color_manual(values=c("blue")) + theme_classic() +
  geom_vline(aes(xintercept=mean(HBx19@meta.data$percent.mt)),
             color="blue", linetype="dashed", size=0.5) +scale_x_continuous(breaks=seq(0, 40, by = 1))
```

### Data Filtering

```{r}
(Count93_nCount_RNA <- quantile(HBx19@meta.data$nCount_RNA, 0.93)) # calculate value in the 93rd percentile for a hint on thresholds but these should be taken with a grain of salt, look at the above plots as well to determine thresholds
(Count93_nFeature_RNA <- quantile(HBx19@meta.data$nFeature_RNA, 0.93))
(Count93_percent_mt <-  quantile(HBx19@meta.data$percent.mt, 0.93))

summary(HBx19@meta.data$nCount_RNA)
summary(HBx19@meta.data$nFeature_RNA)

HBx19 <- subset(HBx19, subset = nFeature_RNA > 200 & nFeature_RNA < 3500 & percent.mt < 10)
```

### Data after filtering based on above thresholds
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx19, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx19, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx19, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(HBx19)
```

## Doublet Removal
Detection of doublets was conducting in python using [scrublet](https://github.com/swolock/scrublet) and a file containing scrublet calls/predictions was written out. This file was then loaded into R to use as a basis for filtering out doublets.

Visualization of the doublet predictions in a 2-D embedding/UAMP. Predicted doublets should mostly co-localize (possibly in multiple clusters). If they do not, you may need to adjust the doublet score threshold, or change the pre-processing parameters to better resolve the cell states present in your data.

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx19/HBx19_doublet_predictions.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

The simulated doublet histogram below should typically be bimodal. The left mode corresponds to "embedded" doublets generated by two cells with similar gene expression. The right mode corresponds to "neotypic" doublets, which are generated by cells with distinct gene expression (e.g., different cell types) and are expected to introduce more artifacts in downstream analyses. Scrublet can only detect neotypic doublets.
This histogram is an important diagnostic plot. Doublet score threshold should separate the two shoulders of the bimodal distribution as shown below:

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx19/HBx19_doublet_predictions_histogram.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

```{r out.height = "460px", out.width='800px', echo=F, eval=FALSE}
knitr::include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx19/HBx19_doublet_predictions_histogram.pdf')
```

```{r}
#Loading scrublet predictions
dim(scrublet_calls <- read.csv("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx19/HBx19_scrublet_calls.csv"))
table(scrublet_calls$predicted_doublets)

scrublet_calls$X <- paste0("Late_Secretory_HBx19_", scrublet_calls$X)

dim(scrublet_calls <- scrublet_calls[which(scrublet_calls$X %in% rownames(HBx19@meta.data)),])
rownames(scrublet_calls) <- scrublet_calls$X
scrublet_calls$X <-NULL
dim(scrublet_calls)

#Adding doublet information to metadata
#First we'll ensure that the rownames in HBx19 match the rownames in scrublet_calls. AddMetaData maps rownames but we'll still do so to ensure that mapping of predictions are made to respective bar codes
scrublet_calls <- scrublet_calls[rownames(HBx19@meta.data), ]
head(rownames(scrublet_calls))
head(rownames(HBx19@meta.data))
HBx19 <- AddMetaData(HBx19, scrublet_calls)
```


```{r, fig.height=4, fig.width=5}
#Without normalizing the data, we want to first visualize the doublets in our datasets
HBx19_Control_2 <- HBx19
HBx19_Control_2 <- FindVariableFeatures(HBx19_Control_2, selection.method = "vst", nfeatures = 2500)
HBx19_Control_2 <- ScaleData(object = HBx19_Control_2, scale.max = 30,  verbose = FALSE)
HBx19_Control_2 <- RunPCA(object = HBx19_Control_2, npcs = 30, verbose = FALSE)
HBx19_Control_2 <- FindNeighbors(HBx19_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
HBx19_Control_2 <- RunUMAP(HBx19_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
HBx19_Control_2 <- FindClusters(HBx19_Control_2, verbose = TRUE, reduction = "pca") #Resolution can be adjusted - leaving to default for now in test dataset

FeaturePlot(HBx19_Control_2, features = "doublet_scores", pt.size = 0.01)

DimPlot(HBx19_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"))

#Checking the nUMI for doublets and singlets
VlnPlot(HBx19_Control_2,
        features = "nCount_RNA",
        pt.size = 0,
        group.by = "predicted_doublets") + NoLegend()

#Fractions of doublets per cluster
df <- data.table(HBx19_Control_2@meta.data)

perc <- as.data.frame(df %>%
                        group_by(seurat_clusters, predicted_doublets) %>%
                        dplyr::summarise(cnt = n()) %>%
                        mutate(freq = formattable::percent(cnt / sum(cnt), digits = 5)))

perc$predicted_doublets <- as.character(perc$predicted_doublets)
perc$predicted_doublets[perc$predicted_doublets == "True"] <- "Doublet"
perc$predicted_doublets[perc$predicted_doublets == "False"] <- "Singlet"
```

```{r, fig.height=3.5, fig.width=7}
perc %>%
  ggplot() +
  geom_bar(aes(x = seurat_clusters, y=freq,
               group = predicted_doublets,
               fill = predicted_doublets),
           stat = "identity", width = 0.99, alpha = 0.9) +
  theme_test()+
  labs(y=paste0("% Distribution of doublets and singlets per cluster"), x="") +
  scale_fill_manual(values = c("Doublet" = 'firebrick4', "Singlet" = "dodgerblue4")) +
  theme(legend.position = "right") +scale_y_continuous(expand = c(0,0))
```

```{r, fig.height=4, fig.width=5}
#Next we'll remove the doublets and see what the data looks like
HBx19_Control_2 <- HBx19_Control_2[, HBx19_Control_2@meta.data[, "predicted_doublets"] == "False"]
unique(HBx19_Control_2@meta.data$predicted_doublets)
DimPlot(HBx19_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"), label = TRUE)
```

**Filtering cells to remove doublets**
```{r}
HBx19 <- HBx19[, HBx19@meta.data[, "predicted_doublets"] == "False"]
unique(HBx19@meta.data$predicted_doublets)
dim(HBx19)
```

### Data after filtering doublets
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx19, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx19, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx19, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(HBx19)
```

### Saving object for further downstream analysis
```{r}
saveRDS(HBx19, file = "/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/QC/HBx19_SeuratObject_soupX_doublet_QC_filtered.rds")
rm(HBx19)
gc()
```


## HBx20 QC

```{r,fig.height=7, fig.width=13}
#We'll store the percentage of reads that map to the mitochondrial genome in the metadata object as "percent.mt"
HBx20[["percent.mt"]] <- PercentageFeatureSet(HBx20, pattern = "^MT-")

#The number of unique genes and total molecules are automatically calculated during `CreateSeuratObject()` and we can find these stored in the object meta data as nFeature_RNA and nCount_RNA respecitvely.
HBx20@meta.data %>%
  head(n=5)
```

**Visualize QC metrics, and use these to filter cells**

```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx20, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx20, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx20, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)
```


```{r, message=FALSE, fig.width=20, fig.height=7}
#FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(HBx20, feature1 = "nCount_RNA", feature2 = "percent.mt", cols = "gray60")
plot2 <- FeatureScatter(HBx20, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", cols = "gray60")
plot1 + plot2
```

**Alternative view of the data and distributions**
```{r, fig.height=3}
df <- as.data.table(HBx20@meta.data)
sel <- c("orig.ident", "nCount_RNA", "nFeature_RNA", "percent.mt")
df <- df[, sel, with = FALSE]
df[1:3, ]
fontsize <- 10
linesize <- 0.35

gp.ls <- df[, 2:4] %>% imap( ~ {

  # define lable function
  give.n <- function(x) {
    return(c(y = median(x) + max(x) / 10, label = round(median(x), 2)))
  }

  # assign colors
  col.ls <-
    setNames(
      c('gray50', 'gray70', 'gray90', "gray" ),
      c("nCount_RNA", "nFeature_RNA", "percent.mt", "log10GenesPerUMI")
    )

  ggplot(data = df, aes(x = orig.ident, y = .x)) +
    geom_violin(trim = FALSE, fill = col.ls[.y]) +
    ggtitle(label = .y) + ylab(label = .y) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_blank(),
      panel.border = element_blank()
    ) +
    theme(
      axis.text = element_text(size = fontsize),
      axis.line = element_line(colour = "black", size = linesize),
      axis.ticks = element_line(size = linesize),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(.05, "cm"),
      plot.title = element_text(size = fontsize + 2, hjust = 0.5),
      legend.position = 'none'
    ) +
    stat_summary(fun = median, geom = "point", col = "black") +  # Add points to plot
    stat_summary(fun.data = give.n,
                 geom = "text",
                 col = "black") + theme_light()
})

grid.arrange(gp.ls[[1]], gp.ls[[2]], gp.ls[[3]], ncol = 3)
```

### Number of cell counts per sample before filtering
```{r, fig.height=4, fig.width=2}
metadata <- HBx20@meta.data
# Add cell IDs to metadata
metadata$cells <- rownames(metadata)

# Rename columns
metadata <- metadata %>%
  dplyr::rename(nUMI = nCount_RNA,
                nGene = nFeature_RNA)

unique(metadata$orig.ident)
# Visualize the number of cell counts per sample
metadata %>%
  ggplot(aes(x=orig.ident, fill=orig.ident)) +
  geom_bar(color = "gray80", fill = "gray80") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells") + theme(legend.position = "none") +
  theme(legend.position = "none") +
  geom_text(stat='count', aes(label=..count..), vjust = 0.5)
```

### Number UMIs/transcripts per cell
```{r, fig.width=4, fig.height=3}
#Visualize the number UMIs/transcripts per cell
ggplot(metadata, aes(x = nUMI)) +
  geom_histogram(aes(y = ..density..),
                 alpha = 0.3, color="gray50", fill="white") +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density/UMI counts per cell") +
  geom_vline(xintercept = 500) + theme(legend.position = "none")+
  geom_density(lwd = 0.5, colour = 4,
               fill = 4, alpha = 0.1)
#The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply
```

### More on Data and QC
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=6}
counts <- Matrix(HBx20@assays$RNA@counts)
counts_per_cell <- Matrix::colSums(counts)
counts_per_gene <- Matrix::rowSums(counts)
genes_per_cell1 <- Matrix::colSums(counts>0) #count a gene only if it has non-zero reads mapped.
cells_per_gene <- Matrix::rowSums(counts>0) #only count cells where the gene is expressed

counts_per_cell <- as.data.frame(colSums(counts))
counts_per_gene <- as.data.frame(rowSums(counts))
genes_per_cell <- as.data.frame(colSums(counts>0))
cells_per_gene <- as.data.frame(rowSums(counts>0) )

colnames(counts_per_cell) <- "counts"
colnames(counts_per_gene) <- "counts"
colnames(genes_per_cell) <- "genes_per_cell"
colnames(cells_per_gene) <- "cells_per_gene"

df <- cbind(counts_per_cell, genes_per_cell)

ggplot(df, aes(x=counts, y=genes_per_cell)) + geom_point(color="gray30") + scale_y_continuous(trans='log10') + scale_x_continuous(trans='log10') + theme_light()

#Plot cells ranked by their number of detected genes.
genes_per_cell$cells <- rownames(genes_per_cell)

#set upper and lower thresholds for genes per cell - the upper and lower limit curve bends give a good clue on what thresholds to set:
min_genes_per_cell <- 200
max_genes_per_cell <- 3000

ggplot(genes_per_cell, aes(x=reorder(genes_per_cell, cells), y=genes_per_cell)) + geom_point() +
  scale_y_continuous(trans='log10', breaks=seq(0, 5000, by = 1000)) + ggtitle("Genes per Cell") + theme_test(base_size = 12) +
  geom_hline(aes(yintercept=min_genes_per_cell),
             color="blue", linetype="dashed", size=0.5) +
  geom_hline(aes(yintercept=max_genes_per_cell), color="blue", linetype="dashed", size=0.5) + labs(x= "Cells", y="Number of Genes") + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
```

### Percent MT Distribution
```{r fig.width=12, fig.height=6}
#Density plot
ggplot(HBx20@meta.data, aes(x=HBx20@meta.data$percent.mt)) +
  geom_density() + scale_color_manual(values=c("blue")) + theme_classic() +
  geom_vline(aes(xintercept=mean(HBx20@meta.data$percent.mt)),
             color="blue", linetype="dashed", size=0.5) +scale_x_continuous(breaks=seq(0, 40, by = 1))
```

### Data Filtering

```{r}
(Count93_nCount_RNA <- quantile(HBx20@meta.data$nCount_RNA, 0.93)) # calculate value in the 93rd percentile for a hint on thresholds but these should be taken with a grain of salt, look at the above plots as well to determine thresholds
(Count93_nFeature_RNA <- quantile(HBx20@meta.data$nFeature_RNA, 0.93))
(Count93_percent_mt <-  quantile(HBx20@meta.data$percent.mt, 0.93))

summary(HBx20@meta.data$nCount_RNA)
summary(HBx20@meta.data$nFeature_RNA)

HBx20 <- subset(HBx20, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 11)
```

### Data after filtering based on above thresholds
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx20, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx20, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx20, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(HBx20)
```

## Doublet Removal
Detection of doublets was conducting in python using [scrublet](https://github.com/swolock/scrublet) and a file containing scrublet calls/predictions was written out. This file was then loaded into R to use as a basis for filtering out doublets.

Visualization of the doublet predictions in a 2-D embedding/UAMP. Predicted doublets should mostly co-localize (possibly in multiple clusters). If they do not, you may need to adjust the doublet score threshold, or change the pre-processing parameters to better resolve the cell states present in your data.

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx20/HBx20_doublet_predictions.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

The simulated doublet histogram below should typically be bimodal. The left mode corresponds to "embedded" doublets generated by two cells with similar gene expression. The right mode corresponds to "neotypic" doublets, which are generated by cells with distinct gene expression (e.g., different cell types) and are expected to introduce more artifacts in downstream analyses. Scrublet can only detect neotypic doublets.
This histogram is an important diagnostic plot. Doublet score threshold should separate the two shoulders of the bimodal distribution as shown below:

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx20/HBx20_doublet_predictions_histogram.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

```{r out.height = "460px", out.width='800px', echo=F, eval=FALSE}
knitr::include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx20/HBx20_doublet_predictions_histogram.pdf')
```

```{r}
#Loading scrublet predictions
dim(scrublet_calls <- read.csv("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/HBx20/HBx20_scrublet_calls.csv"))
table(scrublet_calls$predicted_doublets)

scrublet_calls$X <- paste0("Late_Secretory_HBx20_", scrublet_calls$X)

dim(scrublet_calls <- scrublet_calls[which(scrublet_calls$X %in% rownames(HBx20@meta.data)),])
rownames(scrublet_calls) <- scrublet_calls$X
scrublet_calls$X <-NULL
dim(scrublet_calls)

#Adding doublet information to metadata
#First we'll ensure that the rownames in HBx20 match the rownames in scrublet_calls. AddMetaData maps rownames but we'll still do so to ensure that mapping of predictions are made to respective bar codes
scrublet_calls <- scrublet_calls[rownames(HBx20@meta.data), ]
head(rownames(scrublet_calls))
head(rownames(HBx20@meta.data))
HBx20 <- AddMetaData(HBx20, scrublet_calls)
```


```{r, fig.height=4, fig.width=5}
#Without normalizing the data, we want to first visualize the doublets in our datasets
HBx20_Control_2 <- HBx20
HBx20_Control_2 <- FindVariableFeatures(HBx20_Control_2, selection.method = "vst", nfeatures = 2500)
HBx20_Control_2 <- ScaleData(object = HBx20_Control_2, scale.max = 30,  verbose = FALSE)
HBx20_Control_2 <- RunPCA(object = HBx20_Control_2, npcs = 30, verbose = FALSE)
HBx20_Control_2 <- FindNeighbors(HBx20_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
HBx20_Control_2 <- RunUMAP(HBx20_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
HBx20_Control_2 <- FindClusters(HBx20_Control_2, verbose = TRUE, reduction = "pca") #Resolution can be adjusted - leaving to default for now in test dataset

FeaturePlot(HBx20_Control_2, features = "doublet_scores", pt.size = 0.01)

DimPlot(HBx20_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"))

#Checking the nUMI for doublets and singlets
VlnPlot(HBx20_Control_2,
        features = "nCount_RNA",
        pt.size = 0,
        group.by = "predicted_doublets") + NoLegend()

#Fractions of doublets per cluster
df <- data.table(HBx20_Control_2@meta.data)

perc <- as.data.frame(df %>%
                        group_by(seurat_clusters, predicted_doublets) %>%
                        dplyr::summarise(cnt = n()) %>%
                        mutate(freq = formattable::percent(cnt / sum(cnt), digits = 5)))

perc$predicted_doublets <- as.character(perc$predicted_doublets)
perc$predicted_doublets[perc$predicted_doublets == "True"] <- "Doublet"
perc$predicted_doublets[perc$predicted_doublets == "False"] <- "Singlet"
```

```{r, fig.height=3.5, fig.width=7}
perc %>%
  ggplot() +
  geom_bar(aes(x = seurat_clusters, y=freq,
               group = predicted_doublets,
               fill = predicted_doublets),
           stat = "identity", width = 0.99, alpha = 0.9) +
  theme_test()+
  labs(y=paste0("% Distribution of doublets and singlets per cluster"), x="") +
  scale_fill_manual(values = c("Doublet" = 'firebrick4', "Singlet" = "dodgerblue4")) +
  theme(legend.position = "right") +scale_y_continuous(expand = c(0,0))
```

```{r, fig.height=4, fig.width=5}
#Next we'll remove the doublets and see what the data looks like
HBx20_Control_2 <- HBx20_Control_2[, HBx20_Control_2@meta.data[, "predicted_doublets"] == "False"]
unique(HBx20_Control_2@meta.data$predicted_doublets)
DimPlot(HBx20_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"), label = TRUE)
```

**Filtering cells to remove doublets**
```{r}
HBx20 <- HBx20[, HBx20@meta.data[, "predicted_doublets"] == "False"]
unique(HBx20@meta.data$predicted_doublets)
dim(HBx20)
```

### Data after filtering doublets
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(HBx20, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(HBx20, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(HBx20, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(HBx20)
```

### Saving object for further downstream analysis
```{r}
saveRDS(HBx20, file = "/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/QC/HBx20_SeuratObject_soupX_doublet_QC_filtered.rds")
rm(HBx20)
gc()
```


## UTx01_Bx03 QC

```{r,fig.height=7, fig.width=13}
#We'll store the percentage of reads that map to the mitochondrial genome in the metadata object as "percent.mt"
UTx01_Bx03[["percent.mt"]] <- PercentageFeatureSet(UTx01_Bx03, pattern = "^MT-")

#The number of unique genes and total molecules are automatically calculated during `CreateSeuratObject()` and we can find these stored in the object meta data as nFeature_RNA and nCount_RNA respecitvely.
UTx01_Bx03@meta.data %>%
  head(n=5)
```

**Visualize QC metrics, and use these to filter cells**

```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx01_Bx03, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx01_Bx03, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx01_Bx03, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)
```


```{r, message=FALSE, fig.width=20, fig.height=7}
#FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(UTx01_Bx03, feature1 = "nCount_RNA", feature2 = "percent.mt", cols = "gray60")
plot2 <- FeatureScatter(UTx01_Bx03, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", cols = "gray60")
plot1 + plot2
```

**Alternative view of the data and distributions**
```{r, fig.height=3}
df <- as.data.table(UTx01_Bx03@meta.data)
sel <- c("orig.ident", "nCount_RNA", "nFeature_RNA", "percent.mt")
df <- df[, sel, with = FALSE]
df[1:3, ]
fontsize <- 10
linesize <- 0.35

gp.ls <- df[, 2:4] %>% imap( ~ {

  # define lable function
  give.n <- function(x) {
    return(c(y = median(x) + max(x) / 10, label = round(median(x), 2)))
  }

  # assign colors
  col.ls <-
    setNames(
      c('gray50', 'gray70', 'gray90', "gray" ),
      c("nCount_RNA", "nFeature_RNA", "percent.mt", "log10GenesPerUMI")
    )

  ggplot(data = df, aes(x = orig.ident, y = .x)) +
    geom_violin(trim = FALSE, fill = col.ls[.y]) +
    ggtitle(label = .y) + ylab(label = .y) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_blank(),
      panel.border = element_blank()
    ) +
    theme(
      axis.text = element_text(size = fontsize),
      axis.line = element_line(colour = "black", size = linesize),
      axis.ticks = element_line(size = linesize),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(.05, "cm"),
      plot.title = element_text(size = fontsize + 2, hjust = 0.5),
      legend.position = 'none'
    ) +
    stat_summary(fun = median, geom = "point", col = "black") +  # Add points to plot
    stat_summary(fun.data = give.n,
                 geom = "text",
                 col = "black") + theme_light()
})

grid.arrange(gp.ls[[1]], gp.ls[[2]], gp.ls[[3]], ncol = 3)
```

### Number of cell counts per sample before filtering
```{r, fig.height=4, fig.width=2}
metadata <- UTx01_Bx03@meta.data
# Add cell IDs to metadata
metadata$cells <- rownames(metadata)

# Rename columns
metadata <- metadata %>%
  dplyr::rename(nUMI = nCount_RNA,
                nGene = nFeature_RNA)

unique(metadata$orig.ident)
# Visualize the number of cell counts per sample
metadata %>%
  ggplot(aes(x=orig.ident, fill=orig.ident)) +
  geom_bar(color = "gray80", fill = "gray80") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells") + theme(legend.position = "none") +
  theme(legend.position = "none") +
  geom_text(stat='count', aes(label=..count..), vjust = 0.5)
```

### Number UMIs/transcripts per cell
```{r, fig.width=4, fig.height=3}
#Visualize the number UMIs/transcripts per cell
ggplot(metadata, aes(x = nUMI)) +
  geom_histogram(aes(y = ..density..),
                 alpha = 0.3, color="gray50", fill="white") +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density/UMI counts per cell") +
  geom_vline(xintercept = 500) + theme(legend.position = "none")+
  geom_density(lwd = 0.5, colour = 4,
               fill = 4, alpha = 0.1)
#The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply
```

### More on Data and QC
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=6}
counts <- Matrix(UTx01_Bx03@assays$RNA@counts)
counts_per_cell <- Matrix::colSums(counts)
counts_per_gene <- Matrix::rowSums(counts)
genes_per_cell1 <- Matrix::colSums(counts>0) #count a gene only if it has non-zero reads mapped.
cells_per_gene <- Matrix::rowSums(counts>0) #only count cells where the gene is expressed

counts_per_cell <- as.data.frame(colSums(counts))
counts_per_gene <- as.data.frame(rowSums(counts))
genes_per_cell <- as.data.frame(colSums(counts>0))
cells_per_gene <- as.data.frame(rowSums(counts>0) )

colnames(counts_per_cell) <- "counts"
colnames(counts_per_gene) <- "counts"
colnames(genes_per_cell) <- "genes_per_cell"
colnames(cells_per_gene) <- "cells_per_gene"

df <- cbind(counts_per_cell, genes_per_cell)

ggplot(df, aes(x=counts, y=genes_per_cell)) + geom_point(color="gray30") + scale_y_continuous(trans='log10') + scale_x_continuous(trans='log10') + theme_light()

#Plot cells ranked by their number of detected genes.
genes_per_cell$cells <- rownames(genes_per_cell)

#set upper and lower thresholds for genes per cell - the upper and lower limit curve bends give a good clue on what thresholds to set:
min_genes_per_cell <- 200
max_genes_per_cell <- 3500

ggplot(genes_per_cell, aes(x=reorder(genes_per_cell, cells), y=genes_per_cell)) + geom_point() +
  scale_y_continuous(trans='log10', breaks=seq(0, 5000, by = 1000)) + ggtitle("Genes per Cell") + theme_test(base_size = 12) +
  geom_hline(aes(yintercept=min_genes_per_cell),
             color="blue", linetype="dashed", size=0.5) +
  geom_hline(aes(yintercept=max_genes_per_cell), color="blue", linetype="dashed", size=0.5) + labs(x= "Cells", y="Number of Genes") + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
```

### Percent MT Distribution
```{r fig.width=12, fig.height=6}
#Density plot
ggplot(UTx01_Bx03@meta.data, aes(x=UTx01_Bx03@meta.data$percent.mt)) +
  geom_density() + scale_color_manual(values=c("blue")) + theme_classic() +
  geom_vline(aes(xintercept=mean(UTx01_Bx03@meta.data$percent.mt)),
             color="blue", linetype="dashed", size=0.5) +scale_x_continuous(breaks=seq(0, 40, by = 1))
```

### Data Filtering


```{r}
(Count93_nCount_RNA <- quantile(UTx01_Bx03@meta.data$nCount_RNA, 0.93)) # calculate value in the 93rd percentile for a hint on thresholds but these should be taken with a grain of salt, look at the above plots as well to determine thresholds
(Count93_nFeature_RNA <- quantile(UTx01_Bx03@meta.data$nFeature_RNA, 0.93))
(Count93_percent_mt <-  quantile(UTx01_Bx03@meta.data$percent.mt, 0.93))

summary(UTx01_Bx03@meta.data$nCount_RNA)
summary(UTx01_Bx03@meta.data$nFeature_RNA)

UTx01_Bx03 <- subset(UTx01_Bx03, subset = nFeature_RNA > 200 & nFeature_RNA < 3500 & percent.mt < 10)
```

### Data after filtering based on above thresholds
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx01_Bx03, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx01_Bx03, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx01_Bx03, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(UTx01_Bx03)
```

## Doublet Removal
Detection of doublets was conducting in python using [scrublet](https://github.com/swolock/scrublet) and a file containing scrublet calls/predictions was written out. This file was then loaded into R to use as a basis for filtering out doublets.

Visualization of the doublet predictions in a 2-D embedding/UAMP. Predicted doublets should mostly co-localize (possibly in multiple clusters). If they do not, you may need to adjust the doublet score threshold, or change the pre-processing parameters to better resolve the cell states present in your data.

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx01_Bx03/UTx01_Bx03_doublet_predictions.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

The simulated doublet histogram below should typically be bimodal. The left mode corresponds to "embedded" doublets generated by two cells with similar gene expression. The right mode corresponds to "neotypic" doublets, which are generated by cells with distinct gene expression (e.g., different cell types) and are expected to introduce more artifacts in downstream analyses. Scrublet can only detect neotypic doublets.
This histogram is an important diagnostic plot. Doublet score threshold should separate the two shoulders of the bimodal distribution as shown below:

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx01_Bx03/UTx01_Bx03_doublet_predictions_histogram.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

```{r out.height = "460px", out.width='800px', echo=F, eval=FALSE}
knitr::include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx01_Bx03/UTx01_Bx03_doublet_predictions_histogram.pdf')
```

```{r}
#Loading scrublet predictions
dim(scrublet_calls <- read.csv("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx01_Bx03/UTx01_Bx03_scrublet_calls.csv"))
table(scrublet_calls$predicted_doublets)

scrublet_calls$X <- paste0("Mid_Secretory_UTx01_Bx03_", scrublet_calls$X)

dim(scrublet_calls <- scrublet_calls[which(scrublet_calls$X %in% rownames(UTx01_Bx03@meta.data)),])
rownames(scrublet_calls) <- scrublet_calls$X
scrublet_calls$X <-NULL
dim(scrublet_calls)

#Adding doublet information to metadata
#First we'll ensure that the rownames in UTx01_Bx03 match the rownames in scrublet_calls. AddMetaData maps rownames but we'll still do so to ensure that mapping of predictions are made to respective bar codes
scrublet_calls <- scrublet_calls[rownames(UTx01_Bx03@meta.data), ]
head(rownames(scrublet_calls))
head(rownames(UTx01_Bx03@meta.data))
UTx01_Bx03 <- AddMetaData(UTx01_Bx03, scrublet_calls)
```


```{r, fig.height=4, fig.width=5}
#Without normalizing the data, we want to first visualize the doublets in our datasets
UTx01_Bx03_Control_2 <- UTx01_Bx03
UTx01_Bx03_Control_2 <- FindVariableFeatures(UTx01_Bx03_Control_2, selection.method = "vst", nfeatures = 2500)
UTx01_Bx03_Control_2 <- ScaleData(object = UTx01_Bx03_Control_2, scale.max = 30,  verbose = FALSE)
UTx01_Bx03_Control_2 <- RunPCA(object = UTx01_Bx03_Control_2, npcs = 30, verbose = FALSE)
UTx01_Bx03_Control_2 <- FindNeighbors(UTx01_Bx03_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
UTx01_Bx03_Control_2 <- RunUMAP(UTx01_Bx03_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
UTx01_Bx03_Control_2 <- FindClusters(UTx01_Bx03_Control_2, verbose = TRUE, reduction = "pca") #Resolution can be adjusted - leaving to default for now in test dataset

FeaturePlot(UTx01_Bx03_Control_2, features = "doublet_scores", pt.size = 0.01)

DimPlot(UTx01_Bx03_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"))

#Checking the nUMI for doublets and singlets
VlnPlot(UTx01_Bx03_Control_2,
        features = "nCount_RNA",
        pt.size = 0,
        group.by = "predicted_doublets") + NoLegend()

#Fractions of doublets per cluster
df <- data.table(UTx01_Bx03_Control_2@meta.data)

perc <- as.data.frame(df %>%
                        group_by(seurat_clusters, predicted_doublets) %>%
                        dplyr::summarise(cnt = n()) %>%
                        mutate(freq = formattable::percent(cnt / sum(cnt), digits = 5)))

perc$predicted_doublets <- as.character(perc$predicted_doublets)
perc$predicted_doublets[perc$predicted_doublets == "True"] <- "Doublet"
perc$predicted_doublets[perc$predicted_doublets == "False"] <- "Singlet"
```

```{r, fig.height=3.5, fig.width=7}
perc %>%
  ggplot() +
  geom_bar(aes(x = seurat_clusters, y=freq,
               group = predicted_doublets,
               fill = predicted_doublets),
           stat = "identity", width = 0.99, alpha = 0.9) +
  theme_test()+
  labs(y=paste0("% Distribution of doublets and singlets per cluster"), x="") +
  scale_fill_manual(values = c("Doublet" = 'firebrick4', "Singlet" = "dodgerblue4")) +
  theme(legend.position = "right") +scale_y_continuous(expand = c(0,0))
```

```{r, fig.height=4, fig.width=5}
#Next we'll remove the doublets and see what the data looks like
UTx01_Bx03_Control_2 <- UTx01_Bx03_Control_2[, UTx01_Bx03_Control_2@meta.data[, "predicted_doublets"] == "False"]
unique(UTx01_Bx03_Control_2@meta.data$predicted_doublets)
DimPlot(UTx01_Bx03_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"), label = TRUE)
```

**Filtering cells to remove doublets**
```{r}
UTx01_Bx03 <- UTx01_Bx03[, UTx01_Bx03@meta.data[, "predicted_doublets"] == "False"]
unique(UTx01_Bx03@meta.data$predicted_doublets)
dim(UTx01_Bx03)
```

### Data after filtering doublets
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx01_Bx03, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx01_Bx03, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx01_Bx03, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(UTx01_Bx03)
```

### Saving object for further downstream analysis
```{r}
saveRDS(UTx01_Bx03, file = "/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/QC/UTx01_Bx03_SeuratObject_soupX_doublet_QC_filtered.rds")
rm(UTx01_Bx03)
gc()
```


## UTx01_Bx04 QC

```{r,fig.height=7, fig.width=13}
#We'll store the percentage of reads that map to the mitochondrial genome in the metadata object as "percent.mt"
UTx01_Bx04[["percent.mt"]] <- PercentageFeatureSet(UTx01_Bx04, pattern = "^MT-")

#The number of unique genes and total molecules are automatically calculated during `CreateSeuratObject()` and we can find these stored in the object meta data as nFeature_RNA and nCount_RNA respecitvely.
UTx01_Bx04@meta.data %>%
  head(n=5)
```

**Visualize QC metrics, and use these to filter cells**

```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx01_Bx04, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx01_Bx04, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx01_Bx04, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)
```


```{r, message=FALSE, fig.width=20, fig.height=7}
#FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(UTx01_Bx04, feature1 = "nCount_RNA", feature2 = "percent.mt", cols = "gray60")
plot2 <- FeatureScatter(UTx01_Bx04, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", cols = "gray60")
plot1 + plot2
```

**Alternative view of the data and distributions**
```{r, fig.height=3}
df <- as.data.table(UTx01_Bx04@meta.data)
sel <- c("orig.ident", "nCount_RNA", "nFeature_RNA", "percent.mt")
df <- df[, sel, with = FALSE]
df[1:3, ]
fontsize <- 10
linesize <- 0.35

gp.ls <- df[, 2:4] %>% imap( ~ {

  # define lable function
  give.n <- function(x) {
    return(c(y = median(x) + max(x) / 10, label = round(median(x), 2)))
  }

  # assign colors
  col.ls <-
    setNames(
      c('gray50', 'gray70', 'gray90', "gray" ),
      c("nCount_RNA", "nFeature_RNA", "percent.mt", "log10GenesPerUMI")
    )

  ggplot(data = df, aes(x = orig.ident, y = .x)) +
    geom_violin(trim = FALSE, fill = col.ls[.y]) +
    ggtitle(label = .y) + ylab(label = .y) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_blank(),
      panel.border = element_blank()
    ) +
    theme(
      axis.text = element_text(size = fontsize),
      axis.line = element_line(colour = "black", size = linesize),
      axis.ticks = element_line(size = linesize),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(.05, "cm"),
      plot.title = element_text(size = fontsize + 2, hjust = 0.5),
      legend.position = 'none'
    ) +
    stat_summary(fun = median, geom = "point", col = "black") +  # Add points to plot
    stat_summary(fun.data = give.n,
                 geom = "text",
                 col = "black") + theme_light()
})

grid.arrange(gp.ls[[1]], gp.ls[[2]], gp.ls[[3]], ncol = 3)
```

### Number of cell counts per sample before filtering
```{r, fig.height=4, fig.width=2}
metadata <- UTx01_Bx04@meta.data
# Add cell IDs to metadata
metadata$cells <- rownames(metadata)

# Rename columns
metadata <- metadata %>%
  dplyr::rename(nUMI = nCount_RNA,
                nGene = nFeature_RNA)

unique(metadata$orig.ident)
# Visualize the number of cell counts per sample
metadata %>%
  ggplot(aes(x=orig.ident, fill=orig.ident)) +
  geom_bar(color = "gray80", fill = "gray80") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells") + theme(legend.position = "none") +
  theme(legend.position = "none") +
  geom_text(stat='count', aes(label=..count..), vjust = 0.5)
```

### Number UMIs/transcripts per cell
```{r, fig.width=4, fig.height=3}
#Visualize the number UMIs/transcripts per cell
ggplot(metadata, aes(x = nUMI)) +
  geom_histogram(aes(y = ..density..),
                 alpha = 0.3, color="gray50", fill="white") +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density/UMI counts per cell") +
  geom_vline(xintercept = 500) + theme(legend.position = "none")+
  geom_density(lwd = 0.5, colour = 4,
               fill = 4, alpha = 0.1)
#The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply
```

### More on Data and QC
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=6}
counts <- Matrix(UTx01_Bx04@assays$RNA@counts)
counts_per_cell <- Matrix::colSums(counts)
counts_per_gene <- Matrix::rowSums(counts)
genes_per_cell1 <- Matrix::colSums(counts>0) #count a gene only if it has non-zero reads mapped.
cells_per_gene <- Matrix::rowSums(counts>0) #only count cells where the gene is expressed

counts_per_cell <- as.data.frame(colSums(counts))
counts_per_gene <- as.data.frame(rowSums(counts))
genes_per_cell <- as.data.frame(colSums(counts>0))
cells_per_gene <- as.data.frame(rowSums(counts>0) )

colnames(counts_per_cell) <- "counts"
colnames(counts_per_gene) <- "counts"
colnames(genes_per_cell) <- "genes_per_cell"
colnames(cells_per_gene) <- "cells_per_gene"

df <- cbind(counts_per_cell, genes_per_cell)

ggplot(df, aes(x=counts, y=genes_per_cell)) + geom_point(color="gray30") + scale_y_continuous(trans='log10') + scale_x_continuous(trans='log10') + theme_light()

#Plot cells ranked by their number of detected genes.
genes_per_cell$cells <- rownames(genes_per_cell)

#set upper and lower thresholds for genes per cell - the upper and lower limit curve bends give a good clue on what thresholds to set:
min_genes_per_cell <- 200
max_genes_per_cell <- 4000

ggplot(genes_per_cell, aes(x=reorder(genes_per_cell, cells), y=genes_per_cell)) + geom_point() +
  scale_y_continuous(trans='log10', breaks=seq(0, 5000, by = 1000)) + ggtitle("Genes per Cell") + theme_test(base_size = 12) +
  geom_hline(aes(yintercept=min_genes_per_cell),
             color="blue", linetype="dashed", size=0.5) +
  geom_hline(aes(yintercept=max_genes_per_cell), color="blue", linetype="dashed", size=0.5) + labs(x= "Cells", y="Number of Genes") + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
```

### Percent MT Distribution
```{r fig.width=12, fig.height=6}
#Density plot
ggplot(UTx01_Bx04@meta.data, aes(x=UTx01_Bx04@meta.data$percent.mt)) +
  geom_density() + scale_color_manual(values=c("blue")) + theme_classic() +
  geom_vline(aes(xintercept=mean(UTx01_Bx04@meta.data$percent.mt)),
             color="blue", linetype="dashed", size=0.5) +scale_x_continuous(breaks=seq(0, 40, by = 1))
```

### Data Filtering

```{r}
(Count93_nCount_RNA <- quantile(UTx01_Bx04@meta.data$nCount_RNA, 0.93)) # calculate value in the 93rd percentile for a hint on thresholds but these should be taken with a grain of salt, look at the above plots as well to determine thresholds
(Count93_nFeature_RNA <- quantile(UTx01_Bx04@meta.data$nFeature_RNA, 0.93))
(Count93_percent_mt <-  quantile(UTx01_Bx04@meta.data$percent.mt, 0.93))

summary(UTx01_Bx04@meta.data$nCount_RNA)
summary(UTx01_Bx04@meta.data$nFeature_RNA)

UTx01_Bx04 <- subset(UTx01_Bx04, subset = nFeature_RNA > 200 & nFeature_RNA < 4000 & percent.mt < 12)
```

### Data after filtering based on above thresholds
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx01_Bx04, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx01_Bx04, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx01_Bx04, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(UTx01_Bx04)
```

## Doublet Removal
Detection of doublets was conducting in python using [scrublet](https://github.com/swolock/scrublet) and a file containing scrublet calls/predictions was written out. This file was then loaded into R to use as a basis for filtering out doublets.

Visualization of the doublet predictions in a 2-D embedding/UAMP. Predicted doublets should mostly co-localize (possibly in multiple clusters). If they do not, you may need to adjust the doublet score threshold, or change the pre-processing parameters to better resolve the cell states present in your data.

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx01_Bx04/UTx01_Bx04_doublet_predictions.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

The simulated doublet histogram below should typically be bimodal. The left mode corresponds to "embedded" doublets generated by two cells with similar gene expression. The right mode corresponds to "neotypic" doublets, which are generated by cells with distinct gene expression (e.g., different cell types) and are expected to introduce more artifacts in downstream analyses. Scrublet can only detect neotypic doublets.
This histogram is an important diagnostic plot. Doublet score threshold should separate the two shoulders of the bimodal distribution as shown below:

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx01_Bx04/UTx01_Bx04_doublet_predictions_histogram.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

```{r out.height = "460px", out.width='800px', echo=F, eval=FALSE}
knitr::include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx01_Bx04/UTx01_Bx04_doublet_predictions_histogram.pdf')
```

```{r}
#Loading scrublet predictions
dim(scrublet_calls <- read.csv("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx01_Bx04/UTx01_Bx04_scrublet_calls.csv"))
table(scrublet_calls$predicted_doublets)

scrublet_calls$X <- paste0("Mid_Secretory_UTx01_Bx04_", scrublet_calls$X)

dim(scrublet_calls <- scrublet_calls[which(scrublet_calls$X %in% rownames(UTx01_Bx04@meta.data)),])
rownames(scrublet_calls) <- scrublet_calls$X
scrublet_calls$X <-NULL
dim(scrublet_calls)

#Adding doublet information to metadata
#First we'll ensure that the rownames in UTx01_Bx04 match the rownames in scrublet_calls. AddMetaData maps rownames but we'll still do so to ensure that mapping of predictions are made to respective bar codes
scrublet_calls <- scrublet_calls[rownames(UTx01_Bx04@meta.data), ]
head(rownames(scrublet_calls))
head(rownames(UTx01_Bx04@meta.data))
UTx01_Bx04 <- AddMetaData(UTx01_Bx04, scrublet_calls)
```


```{r, fig.height=4, fig.width=5}
#Without normalizing the data, we want to first visualize the doublets in our datasets
UTx01_Bx04_Control_2 <- UTx01_Bx04
UTx01_Bx04_Control_2 <- FindVariableFeatures(UTx01_Bx04_Control_2, selection.method = "vst", nfeatures = 2500)
UTx01_Bx04_Control_2 <- ScaleData(object = UTx01_Bx04_Control_2, scale.max = 30,  verbose = FALSE)
UTx01_Bx04_Control_2 <- RunPCA(object = UTx01_Bx04_Control_2, npcs = 30, verbose = FALSE)
UTx01_Bx04_Control_2 <- FindNeighbors(UTx01_Bx04_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
UTx01_Bx04_Control_2 <- RunUMAP(UTx01_Bx04_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
UTx01_Bx04_Control_2 <- FindClusters(UTx01_Bx04_Control_2, verbose = TRUE, reduction = "pca") #Resolution can be adjusted - leaving to default for now in test dataset

FeaturePlot(UTx01_Bx04_Control_2, features = "doublet_scores", pt.size = 0.01)

DimPlot(UTx01_Bx04_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"))

#Checking the nUMI for doublets and singlets
VlnPlot(UTx01_Bx04_Control_2,
        features = "nCount_RNA",
        pt.size = 0,
        group.by = "predicted_doublets") + NoLegend()

#Fractions of doublets per cluster
df <- data.table(UTx01_Bx04_Control_2@meta.data)

perc <- as.data.frame(df %>%
                        group_by(seurat_clusters, predicted_doublets) %>%
                        dplyr::summarise(cnt = n()) %>%
                        mutate(freq = formattable::percent(cnt / sum(cnt), digits = 5)))

perc$predicted_doublets <- as.character(perc$predicted_doublets)
perc$predicted_doublets[perc$predicted_doublets == "True"] <- "Doublet"
perc$predicted_doublets[perc$predicted_doublets == "False"] <- "Singlet"
```

```{r, fig.height=3.5, fig.width=7}
perc %>%
  ggplot() +
  geom_bar(aes(x = seurat_clusters, y=freq,
               group = predicted_doublets,
               fill = predicted_doublets),
           stat = "identity", width = 0.99, alpha = 0.9) +
  theme_test()+
  labs(y=paste0("% Distribution of doublets and singlets per cluster"), x="") +
  scale_fill_manual(values = c("Doublet" = 'firebrick4', "Singlet" = "dodgerblue4")) +
  theme(legend.position = "right") +scale_y_continuous(expand = c(0,0))
```

```{r, fig.height=4, fig.width=5}
#Next we'll remove the doublets and see what the data looks like
UTx01_Bx04_Control_2 <- UTx01_Bx04_Control_2[, UTx01_Bx04_Control_2@meta.data[, "predicted_doublets"] == "False"]
unique(UTx01_Bx04_Control_2@meta.data$predicted_doublets)
DimPlot(UTx01_Bx04_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"), label = TRUE)
```

**Filtering cells to remove doublets**
```{r}
UTx01_Bx04 <- UTx01_Bx04[, UTx01_Bx04@meta.data[, "predicted_doublets"] == "False"]
unique(UTx01_Bx04@meta.data$predicted_doublets)
dim(UTx01_Bx04)
```

### Data after filtering doublets
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx01_Bx04, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx01_Bx04, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx01_Bx04, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(UTx01_Bx04)
```

### Saving object for further downstream analysis
```{r}
saveRDS(UTx01_Bx04, file = "/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/QC/UTx01_Bx04_SeuratObject_soupX_doublet_QC_filtered.rds")
rm(UTx01_Bx04)
gc()
```




## UTx01_Bx05 QC

```{r,fig.height=7, fig.width=13}
#We'll store the percentage of reads that map to the mitochondrial genome in the metadata object as "percent.mt"
UTx01_Bx05[["percent.mt"]] <- PercentageFeatureSet(UTx01_Bx05, pattern = "^MT-")

#The number of unique genes and total molecules are automatically calculated during `CreateSeuratObject()` and we can find these stored in the object meta data as nFeature_RNA and nCount_RNA respecitvely.
UTx01_Bx05@meta.data %>%
  head(n=5)
```

**Visualize QC metrics, and use these to filter cells**

```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx01_Bx05, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx01_Bx05, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx01_Bx05, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)
```


```{r, message=FALSE, fig.width=20, fig.height=7}
#FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(UTx01_Bx05, feature1 = "nCount_RNA", feature2 = "percent.mt", cols = "gray60")
plot2 <- FeatureScatter(UTx01_Bx05, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", cols = "gray60")
plot1 + plot2
```

**Alternative view of the data and distributions**
```{r, fig.height=3}
df <- as.data.table(UTx01_Bx05@meta.data)
sel <- c("orig.ident", "nCount_RNA", "nFeature_RNA", "percent.mt")
df <- df[, sel, with = FALSE]
df[1:3, ]
fontsize <- 10
linesize <- 0.35

gp.ls <- df[, 2:4] %>% imap( ~ {

  # define lable function
  give.n <- function(x) {
    return(c(y = median(x) + max(x) / 10, label = round(median(x), 2)))
  }

  # assign colors
  col.ls <-
    setNames(
      c('gray50', 'gray70', 'gray90', "gray" ),
      c("nCount_RNA", "nFeature_RNA", "percent.mt", "log10GenesPerUMI")
    )

  ggplot(data = df, aes(x = orig.ident, y = .x)) +
    geom_violin(trim = FALSE, fill = col.ls[.y]) +
    ggtitle(label = .y) + ylab(label = .y) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_blank(),
      panel.border = element_blank()
    ) +
    theme(
      axis.text = element_text(size = fontsize),
      axis.line = element_line(colour = "black", size = linesize),
      axis.ticks = element_line(size = linesize),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(.05, "cm"),
      plot.title = element_text(size = fontsize + 2, hjust = 0.5),
      legend.position = 'none'
    ) +
    stat_summary(fun = median, geom = "point", col = "black") +  # Add points to plot
    stat_summary(fun.data = give.n,
                 geom = "text",
                 col = "black") + theme_light()
})

grid.arrange(gp.ls[[1]], gp.ls[[2]], gp.ls[[3]], ncol = 3)
```

### Number of cell counts per sample before filtering
```{r, fig.height=4, fig.width=2}
metadata <- UTx01_Bx05@meta.data
# Add cell IDs to metadata
metadata$cells <- rownames(metadata)

# Rename columns
metadata <- metadata %>%
  dplyr::rename(nUMI = nCount_RNA,
                nGene = nFeature_RNA)

unique(metadata$orig.ident)
# Visualize the number of cell counts per sample
metadata %>%
  ggplot(aes(x=orig.ident, fill=orig.ident)) +
  geom_bar(color = "gray80", fill = "gray80") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells") + theme(legend.position = "none") +
  theme(legend.position = "none") +
  geom_text(stat='count', aes(label=..count..), vjust = 0.5)
```

### Number UMIs/transcripts per cell
```{r, fig.width=4, fig.height=3}
#Visualize the number UMIs/transcripts per cell
ggplot(metadata, aes(x = nUMI)) +
  geom_histogram(aes(y = ..density..),
                 alpha = 0.3, color="gray50", fill="white") +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density/UMI counts per cell") +
  geom_vline(xintercept = 500) + theme(legend.position = "none")+
  geom_density(lwd = 0.5, colour = 4,
               fill = 4, alpha = 0.1)
#The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply
```

### More on Data and QC
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=6}
counts <- Matrix(UTx01_Bx05@assays$RNA@counts)
counts_per_cell <- Matrix::colSums(counts)
counts_per_gene <- Matrix::rowSums(counts)
genes_per_cell1 <- Matrix::colSums(counts>0) #count a gene only if it has non-zero reads mapped.
cells_per_gene <- Matrix::rowSums(counts>0) #only count cells where the gene is expressed

counts_per_cell <- as.data.frame(colSums(counts))
counts_per_gene <- as.data.frame(rowSums(counts))
genes_per_cell <- as.data.frame(colSums(counts>0))
cells_per_gene <- as.data.frame(rowSums(counts>0) )

colnames(counts_per_cell) <- "counts"
colnames(counts_per_gene) <- "counts"
colnames(genes_per_cell) <- "genes_per_cell"
colnames(cells_per_gene) <- "cells_per_gene"

df <- cbind(counts_per_cell, genes_per_cell)

ggplot(df, aes(x=counts, y=genes_per_cell)) + geom_point(color="gray30") + scale_y_continuous(trans='log10') + scale_x_continuous(trans='log10') + theme_light()

#Plot cells ranked by their number of detected genes.
genes_per_cell$cells <- rownames(genes_per_cell)

#set upper and lower thresholds for genes per cell - the upper and lower limit curve bends give a good clue on what thresholds to set:
min_genes_per_cell <- 200
max_genes_per_cell <- 3500

ggplot(genes_per_cell, aes(x=reorder(genes_per_cell, cells), y=genes_per_cell)) + geom_point() +
  scale_y_continuous(trans='log10', breaks=seq(0, 5000, by = 1000)) + ggtitle("Genes per Cell") + theme_test(base_size = 12) +
  geom_hline(aes(yintercept=min_genes_per_cell),
             color="blue", linetype="dashed", size=0.5) +
  geom_hline(aes(yintercept=max_genes_per_cell), color="blue", linetype="dashed", size=0.5) + labs(x= "Cells", y="Number of Genes") + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
```

### Percent MT Distribution
```{r fig.width=12, fig.height=6}
#Density plot
ggplot(UTx01_Bx05@meta.data, aes(x=UTx01_Bx05@meta.data$percent.mt)) +
  geom_density() + scale_color_manual(values=c("blue")) + theme_classic() +
  geom_vline(aes(xintercept=mean(UTx01_Bx05@meta.data$percent.mt)),
             color="blue", linetype="dashed", size=0.5) +scale_x_continuous(breaks=seq(0, 40, by = 1))
```

### Data Filtering

```{r}
(Count93_nCount_RNA <- quantile(UTx01_Bx05@meta.data$nCount_RNA, 0.93)) # calculate value in the 93rd percentile for a hint on thresholds but these should be taken with a grain of salt, look at the above plots as well to determine thresholds
(Count93_nFeature_RNA <- quantile(UTx01_Bx05@meta.data$nFeature_RNA, 0.93))
(Count93_percent_mt <-  quantile(UTx01_Bx05@meta.data$percent.mt, 0.93))

summary(UTx01_Bx05@meta.data$nCount_RNA)
summary(UTx01_Bx05@meta.data$nFeature_RNA)

UTx01_Bx05 <- subset(UTx01_Bx05, subset = nFeature_RNA > 200 & nFeature_RNA < 4000 & percent.mt < 15)
```

### Data after filtering based on above thresholds
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx01_Bx05, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx01_Bx05, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx01_Bx05, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(UTx01_Bx05)
```

## Doublet Removal
Detection of doublets was conducting in python using [scrublet](https://github.com/swolock/scrublet) and a file containing scrublet calls/predictions was written out. This file was then loaded into R to use as a basis for filtering out doublets.

Visualization of the doublet predictions in a 2-D embedding/UAMP. Predicted doublets should mostly co-localize (possibly in multiple clusters). If they do not, you may need to adjust the doublet score threshold, or change the pre-processing parameters to better resolve the cell states present in your data.

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx01_Bx05/UTx01_Bx05_doublet_predictions.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

The simulated doublet histogram below should typically be bimodal. The left mode corresponds to "embedded" doublets generated by two cells with similar gene expression. The right mode corresponds to "neotypic" doublets, which are generated by cells with distinct gene expression (e.g., different cell types) and are expected to introduce more artifacts in downstream analyses. Scrublet can only detect neotypic doublets.
This histogram is an important diagnostic plot. Doublet score threshold should separate the two shoulders of the bimodal distribution as shown below:

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx01_Bx05/UTx01_Bx05_doublet_predictions_histogram.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

```{r out.height = "460px", out.width='800px', echo=F, eval=FALSE}
knitr::include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx01_Bx05/UTx01_Bx05_doublet_predictions_histogram.pdf')
```

```{r}
#Loading scrublet predictions
dim(scrublet_calls <- read.csv("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx01_Bx05/UTx01_Bx05_scrublet_calls.csv"))
table(scrublet_calls$predicted_doublets)

scrublet_calls$X <- paste0("Mid_Late_Secretory_UTx01_Bx05_", scrublet_calls$X)

dim(scrublet_calls <- scrublet_calls[which(scrublet_calls$X %in% rownames(UTx01_Bx05@meta.data)),])
rownames(scrublet_calls) <- scrublet_calls$X
scrublet_calls$X <-NULL
dim(scrublet_calls)

#Adding doublet information to metadata
#First we'll ensure that the rownames in UTx01_Bx05 match the rownames in scrublet_calls. AddMetaData maps rownames but we'll still do so to ensure that mapping of predictions are made to respective bar codes
scrublet_calls <- scrublet_calls[rownames(UTx01_Bx05@meta.data), ]
head(rownames(scrublet_calls))
head(rownames(UTx01_Bx05@meta.data))
UTx01_Bx05 <- AddMetaData(UTx01_Bx05, scrublet_calls)
```


```{r, fig.height=4, fig.width=5}
#Without normalizing the data, we want to first visualize the doublets in our datasets
UTx01_Bx05_Control_2 <- UTx01_Bx05
UTx01_Bx05_Control_2 <- FindVariableFeatures(UTx01_Bx05_Control_2, selection.method = "vst", nfeatures = 2500)
UTx01_Bx05_Control_2 <- ScaleData(object = UTx01_Bx05_Control_2, scale.max = 30,  verbose = FALSE)
UTx01_Bx05_Control_2 <- RunPCA(object = UTx01_Bx05_Control_2, npcs = 30, verbose = FALSE)
UTx01_Bx05_Control_2 <- FindNeighbors(UTx01_Bx05_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
UTx01_Bx05_Control_2 <- RunUMAP(UTx01_Bx05_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
UTx01_Bx05_Control_2 <- FindClusters(UTx01_Bx05_Control_2, verbose = TRUE, reduction = "pca") #Resolution can be adjusted - leaving to default for now in test dataset

FeaturePlot(UTx01_Bx05_Control_2, features = "doublet_scores", pt.size = 0.01)

DimPlot(UTx01_Bx05_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"))

#Checking the nUMI for doublets and singlets
VlnPlot(UTx01_Bx05_Control_2,
        features = "nCount_RNA",
        pt.size = 0,
        group.by = "predicted_doublets") + NoLegend()

#Fractions of doublets per cluster
df <- data.table(UTx01_Bx05_Control_2@meta.data)

perc <- as.data.frame(df %>%
                        group_by(seurat_clusters, predicted_doublets) %>%
                        dplyr::summarise(cnt = n()) %>%
                        mutate(freq = formattable::percent(cnt / sum(cnt), digits = 5)))

perc$predicted_doublets <- as.character(perc$predicted_doublets)
perc$predicted_doublets[perc$predicted_doublets == "True"] <- "Doublet"
perc$predicted_doublets[perc$predicted_doublets == "False"] <- "Singlet"
```

```{r, fig.height=3.5, fig.width=7}
perc %>%
  ggplot() +
  geom_bar(aes(x = seurat_clusters, y=freq,
               group = predicted_doublets,
               fill = predicted_doublets),
           stat = "identity", width = 0.99, alpha = 0.9) +
  theme_test()+
  labs(y=paste0("% Distribution of doublets and singlets per cluster"), x="") +
  scale_fill_manual(values = c("Doublet" = 'firebrick4', "Singlet" = "dodgerblue4")) +
  theme(legend.position = "right") +scale_y_continuous(expand = c(0,0))
```

```{r, fig.height=4, fig.width=5}
#Next we'll remove the doublets and see what the data looks like
UTx01_Bx05_Control_2 <- UTx01_Bx05_Control_2[, UTx01_Bx05_Control_2@meta.data[, "predicted_doublets"] == "False"]
unique(UTx01_Bx05_Control_2@meta.data$predicted_doublets)
DimPlot(UTx01_Bx05_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"), label = TRUE)
```

**Filtering cells to remove doublets**
```{r}
UTx01_Bx05 <- UTx01_Bx05[, UTx01_Bx05@meta.data[, "predicted_doublets"] == "False"]
unique(UTx01_Bx05@meta.data$predicted_doublets)
dim(UTx01_Bx05)
```

### Data after filtering doublets
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx01_Bx05, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx01_Bx05, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx01_Bx05, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(UTx01_Bx05)
```

### Saving object for further downstream analysis
```{r}
saveRDS(UTx01_Bx05, file = "/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/QC/UTx01_Bx05_SeuratObject_soupX_doublet_QC_filtered.rds")
rm(UTx01_Bx05)
gc()
```



## UTx03_Bx02 QC

```{r,fig.height=7, fig.width=13}
#We'll store the percentage of reads that map to the mitochondrial genome in the metadata object as "percent.mt"
UTx03_Bx02[["percent.mt"]] <- PercentageFeatureSet(UTx03_Bx02, pattern = "^MT-")

#The number of unique genes and total molecules are automatically calculated during `CreateSeuratObject()` and we can find these stored in the object meta data as nFeature_RNA and nCount_RNA respecitvely.
UTx03_Bx02@meta.data %>%
  head(n=5)
```

**Visualize QC metrics, and use these to filter cells**

```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx03_Bx02, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx03_Bx02, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx03_Bx02, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)
```


```{r, message=FALSE, fig.width=20, fig.height=7}
#FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(UTx03_Bx02, feature1 = "nCount_RNA", feature2 = "percent.mt", cols = "gray60")
plot2 <- FeatureScatter(UTx03_Bx02, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", cols = "gray60")
plot1 + plot2
```

**Alternative view of the data and distributions**
```{r, fig.height=3}
df <- as.data.table(UTx03_Bx02@meta.data)
sel <- c("orig.ident", "nCount_RNA", "nFeature_RNA", "percent.mt")
df <- df[, sel, with = FALSE]
df[1:3, ]
fontsize <- 10
linesize <- 0.35

gp.ls <- df[, 2:4] %>% imap( ~ {

  # define lable function
  give.n <- function(x) {
    return(c(y = median(x) + max(x) / 10, label = round(median(x), 2)))
  }

  # assign colors
  col.ls <-
    setNames(
      c('gray50', 'gray70', 'gray90', "gray" ),
      c("nCount_RNA", "nFeature_RNA", "percent.mt", "log10GenesPerUMI")
    )

  ggplot(data = df, aes(x = orig.ident, y = .x)) +
    geom_violin(trim = FALSE, fill = col.ls[.y]) +
    ggtitle(label = .y) + ylab(label = .y) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_blank(),
      panel.border = element_blank()
    ) +
    theme(
      axis.text = element_text(size = fontsize),
      axis.line = element_line(colour = "black", size = linesize),
      axis.ticks = element_line(size = linesize),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(.05, "cm"),
      plot.title = element_text(size = fontsize + 2, hjust = 0.5),
      legend.position = 'none'
    ) +
    stat_summary(fun = median, geom = "point", col = "black") +  # Add points to plot
    stat_summary(fun.data = give.n,
                 geom = "text",
                 col = "black") + theme_light()
})

grid.arrange(gp.ls[[1]], gp.ls[[2]], gp.ls[[3]], ncol = 3)
```

### Number of cell counts per sample before filtering
```{r, fig.height=4, fig.width=2}
metadata <- UTx03_Bx02@meta.data
# Add cell IDs to metadata
metadata$cells <- rownames(metadata)

# Rename columns
metadata <- metadata %>%
  dplyr::rename(nUMI = nCount_RNA,
                nGene = nFeature_RNA)

unique(metadata$orig.ident)
# Visualize the number of cell counts per sample
metadata %>%
  ggplot(aes(x=orig.ident, fill=orig.ident)) +
  geom_bar(color = "gray80", fill = "gray80") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells") + theme(legend.position = "none") +
  theme(legend.position = "none") +
  geom_text(stat='count', aes(label=..count..), vjust = 0.5)
```

### Number UMIs/transcripts per cell
```{r, fig.width=4, fig.height=3}
#Visualize the number UMIs/transcripts per cell
ggplot(metadata, aes(x = nUMI)) +
  geom_histogram(aes(y = ..density..),
                 alpha = 0.3, color="gray50", fill="white") +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density/UMI counts per cell") +
  geom_vline(xintercept = 500) + theme(legend.position = "none")+
  geom_density(lwd = 0.5, colour = 4,
               fill = 4, alpha = 0.1)
#The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply
```

### More on Data and QC
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=6}
counts <- Matrix(UTx03_Bx02@assays$RNA@counts)
counts_per_cell <- Matrix::colSums(counts)
counts_per_gene <- Matrix::rowSums(counts)
genes_per_cell1 <- Matrix::colSums(counts>0) #count a gene only if it has non-zero reads mapped.
cells_per_gene <- Matrix::rowSums(counts>0) #only count cells where the gene is expressed

counts_per_cell <- as.data.frame(colSums(counts))
counts_per_gene <- as.data.frame(rowSums(counts))
genes_per_cell <- as.data.frame(colSums(counts>0))
cells_per_gene <- as.data.frame(rowSums(counts>0) )

colnames(counts_per_cell) <- "counts"
colnames(counts_per_gene) <- "counts"
colnames(genes_per_cell) <- "genes_per_cell"
colnames(cells_per_gene) <- "cells_per_gene"

df <- cbind(counts_per_cell, genes_per_cell)

ggplot(df, aes(x=counts, y=genes_per_cell)) + geom_point(color="gray30") + scale_y_continuous(trans='log10') + scale_x_continuous(trans='log10') + theme_light()

#Plot cells ranked by their number of detected genes.
genes_per_cell$cells <- rownames(genes_per_cell)

#set upper and lower thresholds for genes per cell - the upper and lower limit curve bends give a good clue on what thresholds to set:
min_genes_per_cell <- 200
max_genes_per_cell <- 3500

ggplot(genes_per_cell, aes(x=reorder(genes_per_cell, cells), y=genes_per_cell)) + geom_point() +
  scale_y_continuous(trans='log10', breaks=seq(0, 5000, by = 1000)) + ggtitle("Genes per Cell") + theme_test(base_size = 12) +
  geom_hline(aes(yintercept=min_genes_per_cell),
             color="blue", linetype="dashed", size=0.5) +
  geom_hline(aes(yintercept=max_genes_per_cell), color="blue", linetype="dashed", size=0.5) + labs(x= "Cells", y="Number of Genes") + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
```

### Percent MT Distribution
```{r fig.width=12, fig.height=6}
#Density plot
ggplot(UTx03_Bx02@meta.data, aes(x=UTx03_Bx02@meta.data$percent.mt)) +
  geom_density() + scale_color_manual(values=c("blue")) + theme_classic() +
  geom_vline(aes(xintercept=mean(UTx03_Bx02@meta.data$percent.mt)),
             color="blue", linetype="dashed", size=0.5) +scale_x_continuous(breaks=seq(0, 40, by = 1))
```

### Data Filtering

```{r}
(Count93_nCount_RNA <- quantile(UTx03_Bx02@meta.data$nCount_RNA, 0.93)) # calculate value in the 93rd percentile for a hint on thresholds but these should be taken with a grain of salt, look at the above plots as well to determine thresholds
(Count93_nFeature_RNA <- quantile(UTx03_Bx02@meta.data$nFeature_RNA, 0.93))
(Count93_percent_mt <-  quantile(UTx03_Bx02@meta.data$percent.mt, 0.93))

summary(UTx03_Bx02@meta.data$nCount_RNA)
summary(UTx03_Bx02@meta.data$nFeature_RNA)

UTx03_Bx02 <- subset(UTx03_Bx02, subset = nFeature_RNA > 200 & nFeature_RNA < 4000 & percent.mt < 15)
```

### Data after filtering based on above thresholds
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx03_Bx02, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx03_Bx02, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx03_Bx02, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(UTx03_Bx02)
```

## Doublet Removal
Detection of doublets was conducting in python using [scrublet](https://github.com/swolock/scrublet) and a file containing scrublet calls/predictions was written out. This file was then loaded into R to use as a basis for filtering out doublets.

Visualization of the doublet predictions in a 2-D embedding/UAMP. Predicted doublets should mostly co-localize (possibly in multiple clusters). If they do not, you may need to adjust the doublet score threshold, or change the pre-processing parameters to better resolve the cell states present in your data.

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx03_Bx02/UTx03_Bx02_doublet_predictions.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

The simulated doublet histogram below should typically be bimodal. The left mode corresponds to "embedded" doublets generated by two cells with similar gene expression. The right mode corresponds to "neotypic" doublets, which are generated by cells with distinct gene expression (e.g., different cell types) and are expected to introduce more artifacts in downstream analyses. Scrublet can only detect neotypic doublets.
This histogram is an important diagnostic plot. Doublet score threshold should separate the two shoulders of the bimodal distribution as shown below:

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx03_Bx02/UTx03_Bx02_doublet_predictions_histogram.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

```{r out.height = "460px", out.width='800px', echo=F, eval=FALSE}
knitr::include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx03_Bx02/UTx03_Bx02_doublet_predictions_histogram.pdf')
```

```{r}
#Loading scrublet predictions
dim(scrublet_calls <- read.csv("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx03_Bx02/UTx03_Bx02_scrublet_calls.csv"))
table(scrublet_calls$predicted_doublets)

scrublet_calls$X <- paste0("Mid_Secretory_UTx03_Bx02_", scrublet_calls$X)

dim(scrublet_calls <- scrublet_calls[which(scrublet_calls$X %in% rownames(UTx03_Bx02@meta.data)),])
rownames(scrublet_calls) <- scrublet_calls$X
scrublet_calls$X <-NULL
dim(scrublet_calls)

#Adding doublet information to metadata
#First we'll ensure that the rownames in UTx03_Bx02 match the rownames in scrublet_calls. AddMetaData maps rownames but we'll still do so to ensure that mapping of predictions are made to respective bar codes
scrublet_calls <- scrublet_calls[rownames(UTx03_Bx02@meta.data), ]
head(rownames(scrublet_calls))
head(rownames(UTx03_Bx02@meta.data))
UTx03_Bx02 <- AddMetaData(UTx03_Bx02, scrublet_calls)
```


```{r, fig.height=4, fig.width=5}
#Without normalizing the data, we want to first visualize the doublets in our datasets
UTx03_Bx02_Control_2 <- UTx03_Bx02
UTx03_Bx02_Control_2 <- FindVariableFeatures(UTx03_Bx02_Control_2, selection.method = "vst", nfeatures = 2500)
UTx03_Bx02_Control_2 <- ScaleData(object = UTx03_Bx02_Control_2, scale.max = 30,  verbose = FALSE)
UTx03_Bx02_Control_2 <- RunPCA(object = UTx03_Bx02_Control_2, npcs = 30, verbose = FALSE)
UTx03_Bx02_Control_2 <- FindNeighbors(UTx03_Bx02_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
UTx03_Bx02_Control_2 <- RunUMAP(UTx03_Bx02_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
UTx03_Bx02_Control_2 <- FindClusters(UTx03_Bx02_Control_2, verbose = TRUE, reduction = "pca") #Resolution can be adjusted - leaving to default for now in test dataset

FeaturePlot(UTx03_Bx02_Control_2, features = "doublet_scores", pt.size = 0.01)

DimPlot(UTx03_Bx02_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"))

#Checking the nUMI for doublets and singlets
VlnPlot(UTx03_Bx02_Control_2,
        features = "nCount_RNA",
        pt.size = 0,
        group.by = "predicted_doublets") + NoLegend()

#Fractions of doublets per cluster
df <- data.table(UTx03_Bx02_Control_2@meta.data)

perc <- as.data.frame(df %>%
                        group_by(seurat_clusters, predicted_doublets) %>%
                        dplyr::summarise(cnt = n()) %>%
                        mutate(freq = formattable::percent(cnt / sum(cnt), digits = 5)))

perc$predicted_doublets <- as.character(perc$predicted_doublets)
perc$predicted_doublets[perc$predicted_doublets == "True"] <- "Doublet"
perc$predicted_doublets[perc$predicted_doublets == "False"] <- "Singlet"
```

```{r, fig.height=3.5, fig.width=7}
perc %>%
  ggplot() +
  geom_bar(aes(x = seurat_clusters, y=freq,
               group = predicted_doublets,
               fill = predicted_doublets),
           stat = "identity", width = 0.99, alpha = 0.9) +
  theme_test()+
  labs(y=paste0("% Distribution of doublets and singlets per cluster"), x="") +
  scale_fill_manual(values = c("Doublet" = 'firebrick4', "Singlet" = "dodgerblue4")) +
  theme(legend.position = "right") +scale_y_continuous(expand = c(0,0))
```

```{r, fig.height=4, fig.width=5}
#Next we'll remove the doublets and see what the data looks like
UTx03_Bx02_Control_2 <- UTx03_Bx02_Control_2[, UTx03_Bx02_Control_2@meta.data[, "predicted_doublets"] == "False"]
unique(UTx03_Bx02_Control_2@meta.data$predicted_doublets)
DimPlot(UTx03_Bx02_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"), label = TRUE)
```

**Filtering cells to remove doublets**
```{r}
UTx03_Bx02 <- UTx03_Bx02[, UTx03_Bx02@meta.data[, "predicted_doublets"] == "False"]
unique(UTx03_Bx02@meta.data$predicted_doublets)
dim(UTx03_Bx02)
```

### Data after filtering doublets
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx03_Bx02, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx03_Bx02, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx03_Bx02, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(UTx03_Bx02)
```

### Saving object for further downstream analysis
```{r}
saveRDS(UTx03_Bx02, file = "/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/QC/UTx03_Bx02_SeuratObject_soupX_doublet_QC_filtered.rds")
rm(UTx03_Bx02)
gc()
```



## UTx03_Bx03 QC

```{r,fig.height=7, fig.width=13}
#We'll store the percentage of reads that map to the mitochondrial genome in the metadata object as "percent.mt"
UTx03_Bx03[["percent.mt"]] <- PercentageFeatureSet(UTx03_Bx03, pattern = "^MT-")

#The number of unique genes and total molecules are automatically calculated during `CreateSeuratObject()` and we can find these stored in the object meta data as nFeature_RNA and nCount_RNA respecitvely.
UTx03_Bx03@meta.data %>%
  head(n=5)
```

**Visualize QC metrics, and use these to filter cells**

```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx03_Bx03, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx03_Bx03, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx03_Bx03, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)
```


```{r, message=FALSE, fig.width=20, fig.height=7}
#FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(UTx03_Bx03, feature1 = "nCount_RNA", feature2 = "percent.mt", cols = "gray60")
plot2 <- FeatureScatter(UTx03_Bx03, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", cols = "gray60")
plot1 + plot2
```

**Alternative view of the data and distributions**
```{r, fig.height=3}
df <- as.data.table(UTx03_Bx03@meta.data)
sel <- c("orig.ident", "nCount_RNA", "nFeature_RNA", "percent.mt")
df <- df[, sel, with = FALSE]
df[1:3, ]
fontsize <- 10
linesize <- 0.35

gp.ls <- df[, 2:4] %>% imap( ~ {

  # define lable function
  give.n <- function(x) {
    return(c(y = median(x) + max(x) / 10, label = round(median(x), 2)))
  }

  # assign colors
  col.ls <-
    setNames(
      c('gray50', 'gray70', 'gray90', "gray" ),
      c("nCount_RNA", "nFeature_RNA", "percent.mt", "log10GenesPerUMI")
    )

  ggplot(data = df, aes(x = orig.ident, y = .x)) +
    geom_violin(trim = FALSE, fill = col.ls[.y]) +
    ggtitle(label = .y) + ylab(label = .y) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_blank(),
      panel.border = element_blank()
    ) +
    theme(
      axis.text = element_text(size = fontsize),
      axis.line = element_line(colour = "black", size = linesize),
      axis.ticks = element_line(size = linesize),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(.05, "cm"),
      plot.title = element_text(size = fontsize + 2, hjust = 0.5),
      legend.position = 'none'
    ) +
    stat_summary(fun = median, geom = "point", col = "black") +  # Add points to plot
    stat_summary(fun.data = give.n,
                 geom = "text",
                 col = "black") + theme_light()
})

grid.arrange(gp.ls[[1]], gp.ls[[2]], gp.ls[[3]], ncol = 3)
```

### Number of cell counts per sample before filtering
```{r, fig.height=4, fig.width=2}
metadata <- UTx03_Bx03@meta.data
# Add cell IDs to metadata
metadata$cells <- rownames(metadata)

# Rename columns
metadata <- metadata %>%
  dplyr::rename(nUMI = nCount_RNA,
                nGene = nFeature_RNA)

unique(metadata$orig.ident)
# Visualize the number of cell counts per sample
metadata %>%
  ggplot(aes(x=orig.ident, fill=orig.ident)) +
  geom_bar(color = "gray80", fill = "gray80") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("NCells") + theme(legend.position = "none") +
  theme(legend.position = "none") +
  geom_text(stat='count', aes(label=..count..), vjust = 0.5)
```

### Number UMIs/transcripts per cell
```{r, fig.width=4, fig.height=3}
#Visualize the number UMIs/transcripts per cell
ggplot(metadata, aes(x = nUMI)) +
  geom_histogram(aes(y = ..density..),
                 alpha = 0.3, color="gray50", fill="white") +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density/UMI counts per cell") +
  geom_vline(xintercept = 500) + theme(legend.position = "none")+
  geom_density(lwd = 0.5, colour = 4,
               fill = 4, alpha = 0.1)
#The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply
```

### More on Data and QC
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=6}
counts <- Matrix(UTx03_Bx03@assays$RNA@counts)
counts_per_cell <- Matrix::colSums(counts)
counts_per_gene <- Matrix::rowSums(counts)
genes_per_cell1 <- Matrix::colSums(counts>0) #count a gene only if it has non-zero reads mapped.
cells_per_gene <- Matrix::rowSums(counts>0) #only count cells where the gene is expressed

counts_per_cell <- as.data.frame(colSums(counts))
counts_per_gene <- as.data.frame(rowSums(counts))
genes_per_cell <- as.data.frame(colSums(counts>0))
cells_per_gene <- as.data.frame(rowSums(counts>0) )

colnames(counts_per_cell) <- "counts"
colnames(counts_per_gene) <- "counts"
colnames(genes_per_cell) <- "genes_per_cell"
colnames(cells_per_gene) <- "cells_per_gene"

df <- cbind(counts_per_cell, genes_per_cell)

ggplot(df, aes(x=counts, y=genes_per_cell)) + geom_point(color="gray30") + scale_y_continuous(trans='log10') + scale_x_continuous(trans='log10') + theme_light()

#Plot cells ranked by their number of detected genes.
genes_per_cell$cells <- rownames(genes_per_cell)

#set upper and lower thresholds for genes per cell - the upper and lower limit curve bends give a good clue on what thresholds to set:
min_genes_per_cell <- 200
max_genes_per_cell <- 3500

ggplot(genes_per_cell, aes(x=reorder(genes_per_cell, cells), y=genes_per_cell)) + geom_point() +
  scale_y_continuous(trans='log10', breaks=seq(0, 5000, by = 1000)) + ggtitle("Genes per Cell") + theme_test(base_size = 12) +
  geom_hline(aes(yintercept=min_genes_per_cell),
             color="blue", linetype="dashed", size=0.5) +
  geom_hline(aes(yintercept=max_genes_per_cell), color="blue", linetype="dashed", size=0.5) + labs(x= "Cells", y="Number of Genes") + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
```

### Percent MT Distribution
```{r fig.width=12, fig.height=6}
#Density plot
ggplot(UTx03_Bx03@meta.data, aes(x=UTx03_Bx03@meta.data$percent.mt)) +
  geom_density() + scale_color_manual(values=c("blue")) + theme_classic() +
  geom_vline(aes(xintercept=mean(UTx03_Bx03@meta.data$percent.mt)),
             color="blue", linetype="dashed", size=0.5) +scale_x_continuous(breaks=seq(0, 40, by = 1))
```

### Data Filtering

```{r}
(Count93_nCount_RNA <- quantile(UTx03_Bx03@meta.data$nCount_RNA, 0.93)) # calculate value in the 93rd percentile for a hint on thresholds but these should be taken with a grain of salt, look at the above plots as well to determine thresholds
(Count93_nFeature_RNA <- quantile(UTx03_Bx03@meta.data$nFeature_RNA, 0.93))
(Count93_percent_mt <-  quantile(UTx03_Bx03@meta.data$percent.mt, 0.93))

summary(UTx03_Bx03@meta.data$nCount_RNA)
summary(UTx03_Bx03@meta.data$nFeature_RNA)

UTx03_Bx03 <- subset(UTx03_Bx03, subset = nFeature_RNA > 200 & nFeature_RNA < 3500 & percent.mt < 12)
```

### Data after filtering based on above thresholds
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx03_Bx03, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx03_Bx03, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx03_Bx03, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(UTx03_Bx03)
```

## Doublet Removal
Detection of doublets was conducting in python using [scrublet](https://github.com/swolock/scrublet) and a file containing scrublet calls/predictions was written out. This file was then loaded into R to use as a basis for filtering out doublets.

Visualization of the doublet predictions in a 2-D embedding/UAMP. Predicted doublets should mostly co-localize (possibly in multiple clusters). If they do not, you may need to adjust the doublet score threshold, or change the pre-processing parameters to better resolve the cell states present in your data.

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx03_Bx03/UTx03_Bx03_doublet_predictions.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

The simulated doublet histogram below should typically be bimodal. The left mode corresponds to "embedded" doublets generated by two cells with similar gene expression. The right mode corresponds to "neotypic" doublets, which are generated by cells with distinct gene expression (e.g., different cell types) and are expected to introduce more artifacts in downstream analyses. Scrublet can only detect neotypic doublets.
This histogram is an important diagnostic plot. Doublet score threshold should separate the two shoulders of the bimodal distribution as shown below:

```{r, out.width = '70%', include=TRUE, fig.align="center", fig.cap=c("scrublet_predictions")}
include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx03_Bx03/UTx03_Bx03_doublet_predictions_histogram.pdf', auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
                 error = getOption("knitr.graphics.error", TRUE), dpi = 300)
```

```{r out.height = "460px", out.width='800px', echo=F, eval=FALSE}
knitr::include_graphics('/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx03_Bx03/UTx03_Bx03_doublet_predictions_histogram.pdf')
```

```{r}
#Loading scrublet predictions
dim(scrublet_calls <- read.csv("/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/scrublet_predictions/UTx03_Bx03/UTx03_Bx03_scrublet_calls.csv"))
table(scrublet_calls$predicted_doublets)

scrublet_calls$X <- paste0("Early_Secretory_UTx03_Bx03_", scrublet_calls$X)

dim(scrublet_calls <- scrublet_calls[which(scrublet_calls$X %in% rownames(UTx03_Bx03@meta.data)),])
rownames(scrublet_calls) <- scrublet_calls$X
scrublet_calls$X <-NULL
dim(scrublet_calls)

#Adding doublet information to metadata
#First we'll ensure that the rownames in UTx03_Bx03 match the rownames in scrublet_calls. AddMetaData maps rownames but we'll still do so to ensure that mapping of predictions are made to respective bar codes
scrublet_calls <- scrublet_calls[rownames(UTx03_Bx03@meta.data), ]
head(rownames(scrublet_calls))
head(rownames(UTx03_Bx03@meta.data))
UTx03_Bx03 <- AddMetaData(UTx03_Bx03, scrublet_calls)
```


```{r, fig.height=4, fig.width=5}
#Without normalizing the data, we want to first visualize the doublets in our datasets
UTx03_Bx03_Control_2 <- UTx03_Bx03
UTx03_Bx03_Control_2 <- FindVariableFeatures(UTx03_Bx03_Control_2, selection.method = "vst", nfeatures = 2500)
UTx03_Bx03_Control_2 <- ScaleData(object = UTx03_Bx03_Control_2, scale.max = 30,  verbose = FALSE)
UTx03_Bx03_Control_2 <- RunPCA(object = UTx03_Bx03_Control_2, npcs = 30, verbose = FALSE)
UTx03_Bx03_Control_2 <- FindNeighbors(UTx03_Bx03_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
UTx03_Bx03_Control_2 <- RunUMAP(UTx03_Bx03_Control_2, dims = 1:20, verbose = TRUE, reduction = "pca")
UTx03_Bx03_Control_2 <- FindClusters(UTx03_Bx03_Control_2, verbose = TRUE, reduction = "pca") #Resolution can be adjusted - leaving to default for now in test dataset

FeaturePlot(UTx03_Bx03_Control_2, features = "doublet_scores", pt.size = 0.01)

DimPlot(UTx03_Bx03_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"))

#Checking the nUMI for doublets and singlets
VlnPlot(UTx03_Bx03_Control_2,
        features = "nCount_RNA",
        pt.size = 0,
        group.by = "predicted_doublets") + NoLegend()

#Fractions of doublets per cluster
df <- data.table(UTx03_Bx03_Control_2@meta.data)

perc <- as.data.frame(df %>%
                        group_by(seurat_clusters, predicted_doublets) %>%
                        dplyr::summarise(cnt = n()) %>%
                        mutate(freq = formattable::percent(cnt / sum(cnt), digits = 5)))

perc$predicted_doublets <- as.character(perc$predicted_doublets)
perc$predicted_doublets[perc$predicted_doublets == "True"] <- "Doublet"
perc$predicted_doublets[perc$predicted_doublets == "False"] <- "Singlet"
```

```{r, fig.height=3.5, fig.width=7}
perc %>%
  ggplot() +
  geom_bar(aes(x = seurat_clusters, y=freq,
               group = predicted_doublets,
               fill = predicted_doublets),
           stat = "identity", width = 0.99, alpha = 0.9) +
  theme_test()+
  labs(y=paste0("% Distribution of doublets and singlets per cluster"), x="") +
  scale_fill_manual(values = c("Doublet" = 'firebrick4', "Singlet" = "dodgerblue4")) +
  theme(legend.position = "right") +scale_y_continuous(expand = c(0,0))
```

```{r, fig.height=4, fig.width=5}
#Next we'll remove the doublets and see what the data looks like
UTx03_Bx03_Control_2 <- UTx03_Bx03_Control_2[, UTx03_Bx03_Control_2@meta.data[, "predicted_doublets"] == "False"]
unique(UTx03_Bx03_Control_2@meta.data$predicted_doublets)
DimPlot(UTx03_Bx03_Control_2, group.by = "predicted_doublets", pt.size = 0.01, cols = c("gray90", "firebrick3"), label = TRUE)
```

**Filtering cells to remove doublets**
```{r}
UTx03_Bx03 <- UTx03_Bx03[, UTx03_Bx03@meta.data[, "predicted_doublets"] == "False"]
unique(UTx03_Bx03@meta.data$predicted_doublets)
dim(UTx03_Bx03)
```

### Data after filtering doublets
```{r, message=FALSE, fig.height=4}
#Visualize QC metrics as violin plots
p1 <- VlnPlot(UTx03_Bx03, features = c("nFeature_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p2 <- VlnPlot(UTx03_Bx03, features = c("nCount_RNA"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
p3 <- VlnPlot(UTx03_Bx03, features = c("percent.mt"), ncol = 1, cols = "skyblue") + theme_light(base_size = 14) + theme(legend.position = "none", plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
grid.arrange(p1, p2, p3, ncol=3)

dim(UTx03_Bx03)
```

### Saving object for further downstream analysis
```{r}
saveRDS(UTx03_Bx03, file = "/data/project/porrettlab/lab_members/rasiimwe/HC_UTx_sample_analytics/QC/UTx03_Bx03_SeuratObject_soupX_doublet_QC_filtered.rds")
rm(UTx03_Bx03)
gc()
```



